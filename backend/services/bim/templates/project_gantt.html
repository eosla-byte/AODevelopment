<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ project.name }} - Cronograma Avanzado</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Frappe Gantt -->
    <script src="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --header-height: 64px;
            /* Compact Toolbar */
            --grid-width: 40%;
            --row-height: 38px;
            --border-color: #e5e7eb;
            --primary-color: #3b82f6;
        }

        body {
            height: 100vh;
            overflow: hidden;
            background: #f9fafb;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
        }

        /* --- Toolbar (Single Row Modern) --- */
        #main-toolbar {
            height: var(--header-height);
            background: white;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 1rem;
            gap: 1rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            z-index: 20;
            overflow-x: auto;
            white-space: nowrap;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding-right: 1rem;
            border-right: 1px solid #e5e7eb;
            height: 60%;
        }

        .toolbar-section:last-child {
            border-right: none;
        }

        .toolbar-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1f2937;
            margin-right: 0.5rem;
        }

        .tool-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 6px;
            color: #4b5563;
            transition: all 0.2s;
            border: 1px solid transparent;
            background: transparent;
        }

        .tool-btn:hover {
            background: #f3f4f6;
            color: #111827;
        }

        .tool-btn.active {
            background: #e0f2fe;
            color: #0284c7;
            border-color: #bae6fd;
        }

        .tool-btn i {
            font-size: 14px;
        }

        /* Input Controls */
        .tool-select {
            height: 28px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 13px;
            color: #374151;
            padding: 0 4px;
            background-color: white;
        }

        .tool-select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 1px var(--primary-color);
        }

        /* --- Strict Split Layout --- */
        #gantt-container {
            flex: 1;
            display: flex;
            flex-direction: row;
            /* Horizontal Split */
            overflow: hidden;
            position: relative;
            width: 100%;
        }

        /* Left Pane: Data Grid */
        #tasks-grid {
            width: var(--grid-width);
            min-width: 400px;
            /* Ensure enough space for columns */
            max-width: 70%;
            overflow: auto;
            background: white;
            border-right: 3px solid #d1d5db;
            /* Visible Divider */
            display: flex;
            flex-direction: column;
            z-index: 10;
        }

        /* Chart Area */
        #chart-area {
            flex: 1;
            overflow: auto;
            position: relative;
            background: #fff;
            min-width: 300px;
        }

        #gantt-target {
            /* Let library control size */
            display: block;
        }

        /* --- Restored Styles --- */
        .gantt-table tr.selected {
            background-color: #eff6ff;
        }

        .gantt-table tr:hover {
            background-color: #f9fafb;
        }

        .summary-task {
            background-color: #f8fafc;
        }

        .summary-task input {
            font-weight: 700;
        }

        .cell-input {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            outline: none;
            font-family: inherit;
        }

        .cell-input:focus {
            background: white;
            box-shadow: inset 0 0 0 1px #3b82f6;
        }

        .wbs-indent {
            display: inline-block;
            width: 0px;
        }

        .toggle-icon {
            cursor: pointer;
            color: #6b7280;
            font-size: 10px;
            margin-right: 4px;
            width: 12px;
            display: inline-block;
            text-align: center;
        }

        .gantt .grid-row {
            height: var(--row-height);
            fill: white;
        }

        .gantt .grid-row:nth-child(even) {
            fill: #fcfcfc;
        }

        .gantt .row-line {
            border-top: 1px solid #f0f0f0;
        }

        .today-highlight {
            stroke: #f59e0b;
            stroke-width: 2;
            stroke-dasharray: 4;
            opacity: 0.7;
        }
    </style>
</head>

<body>

    <!-- Global Error Handler -->
    <div id="global-error"
        style="display:none; background:#fee2e2; color:#b91c1c; padding:10px; text-align:center; border-bottom:1px solid #ef4444;">
    </div>
    <script>
        window.onerror = function (msg, url, line, col, error) {
            const div = document.getElementById('global-error');
            div.style.display = 'block';
            div.innerText = `Error Crítico: ${msg} (Línea ${line})`;
            console.error("Global Error:", error);
            return false;
        };
    </script>

    <!-- TOOLBAR -->
    <div id="main-toolbar">
        <div class="toolbar-section">
            <h1 class="toolbar-title">{{ project.name }}</h1>
        </div>

        <!-- ACTIONS -->
        <div class="toolbar-section">
            <button class="tool-btn" onclick="addLink()" title="Vincular Tareas (Link)">
                <i class="fas fa-link"></i>
            </button>
            <button class="tool-btn" onclick="removeLink()" title="Desvincular (Unlink)">
                <i class="fas fa-unlink"></i>
            </button>
            <div class="w-px h-6 bg-gray-200 mx-1"></div>
            <button class="tool-btn" onclick="indentTask(1)" title="Indentar (Tab)">
                <i class="fas fa-indent"></i>
            </button>
            <button class="tool-btn" onclick="indentTask(-1)" title="Desindentar (Shift+Tab)">
                <i class="fas fa-outdent"></i>
            </button>
        </div>

        <!-- CRUD -->
        <div class="toolbar-section">
            <button class="tool-btn hover:bg-green-50 hover:text-green-600" onclick="addTask()" title="Nueva Tarea">
                <i class="fas fa-plus"></i>
            </button>
            <button class="tool-btn hover:bg-red-50 hover:text-red-600" onclick="deleteTask()" title="Eliminar Tarea">
                <i class="fas fa-trash"></i>
            </button>
            <div class="w-px h-6 bg-gray-200 mx-1"></div>
            <button class="tool-btn" onclick="moveTask(-1)" title="Mover Arriba">
                <i class="fas fa-arrow-up"></i>
            </button>
            <button class="tool-btn" onclick="moveTask(1)" title="Mover Abajo">
                <i class="fas fa-arrow-down"></i>
            </button>
        </div>

        <!-- FONT & STYLE -->
        <div class="toolbar-section">
            <select id="font-family" class="tool-select w-24" onchange="applyStyle('fontFamily', this.value)">
                <option value="Segoe UI">Segoe UI</option>
                <option value="Calibri">Calibri</option>
                <option value="Arial">Arial</option>
                <option value="Times New Roman">Times</option>
            </select>
            <select id="font-size" class="tool-select w-14" onchange="applyStyle('fontSize', this.value + 'px')">
                <option value="11">11</option>
                <option value="12" selected>12</option>
                <option value="14">14</option>
                <option value="16">16</option>
            </select>
            <div class="w-px h-6 bg-gray-200 mx-1"></div>
            <button class="tool-btn font-bold" onclick="toggleStyle('bold')" title="Negrita">N</button>
            <button class="tool-btn italic" onclick="toggleStyle('italic')" title="Cursiva">K</button>
            <button class="tool-btn underline" onclick="toggleStyle('underline')" title="Subrayado">S</button>

            <div class="w-px h-6 bg-gray-200 mx-1"></div>

            <!-- Color Pickers with Icon Labels -->
            <div class="relative group flex items-center">
                <button class="tool-btn" title="Color de Relleno"><i class="fas fa-fill-drip"></i></button>
                <input type="color" class="absolute inset-0 opacity-0 cursor-pointer w-8"
                    onchange="applyStyle('fill', this.value)">
            </div>
            <div class="relative group flex items-center">
                <button class="tool-btn" title="Color de Texto"><i class="fas fa-font"></i></button>
                <input type="color" class="absolute inset-0 opacity-0 cursor-pointer w-8"
                    onchange="applyStyle('color', this.value)">
            </div>
        </div>

        <!-- VIEW MODE -->
        <div class="toolbar-section">
            <button class="tool-btn px-3 w-auto text-xs font-semibold" onclick="changeView('Day')">Dia</button>
            <button class="tool-btn px-3 w-auto text-xs font-semibold" onclick="changeView('Week')">Sem</button>
            <button class="tool-btn px-3 w-auto text-xs font-semibold" onclick="changeView('Month')">Mes</button>
        </div>

        <!-- IMPORT (Right Aligned) -->
        <div class="ml-auto">
            <button onclick="document.getElementById('file-upload').click()"
                class="bg-emerald-600 text-white px-4 py-1.5 rounded-md text-sm font-medium flex items-center gap-2 hover:bg-emerald-700 shadow-sm transition-colors">
                <i class="fas fa-file-import"></i> Importar
            </button>
            <input type="file" id="file-upload" hidden accept=".xml,.mpp,.xer">
        </div>
    </div>

    <!-- MAIN CONTENT -->
    <div id="gantt-container">
        <!-- GRID -->
        <div id="tasks-grid">
            <table class="gantt-table">
                <thead>
                    <tr>
                        <th style="width: 40px;">ID</th>
                        <th style="width: 250px;">Nombre de Tarea</th>
                        <th style="width: 120px;">Empresa</th>
                        <th style="width: 70px;">Dur.</th>
                        <th style="width: 90px;">Inicio</th>
                        <th style="width: 90px;">Fin</th>
                        <th style="width: 60px;">%</th>
                    </tr>
                </thead>
                <tbody id="grid-body">
                    <!-- Dynamic Rows -->
                </tbody>
            </table>
        </div>

        <!-- RESIZER -->
        <div id="resizer"></div>

        <!-- CHART -->
        <div id="chart-area" class="no-scroll">
            <svg id="gantt-target"></svg>
        </div>
    </div>

    <style>
        /* ... Previous Styles ... */

        /* Today Line */
        .today-line {
            stroke: #ef4444;
            stroke-width: 2;
            stroke-dasharray: 4;
            opacity: 0.8;
            pointer-events: none;
            z-index: 50;
        }

        /* Grid Interactive Styles */
        .grid-cell {
            position: relative;
            padding: 0;
            height: 100%;
            cursor: cell;
            outline: none;
        }

        .grid-cell.selected {
            box-shadow: inset 0 0 0 2px #3b82f6;
            background-color: rgba(59, 130, 246, 0.05);
        }

        .grid-cell.editing .cell-input {
            pointer-events: auto;
            background: white;
            box-shadow: inset 0 0 0 2px #3b82f6;
        }

        .cell-input {
            width: 100%;
            height: 100%;
            border: none;
            outline: none;
            background: transparent;
            font-family: inherit;
            padding: 0 6px;
            pointer-events: none;
            /* Default: Selection Mode */
        }
    </style>



    <script>
        // --- STATE ---
        let tasks = {{ tasks | tojson | safe}};
        let gantt;
        let selectedTaskIds = new Set(); // Row selection (Legacy, arguably can merge with cell selection but keeping for row ops)
        const projectId = "{{ project.id }}";

        // Grid Selection State
        let selectedCells = new Set(); // Strings: "rowId:field"
        let lastSelectedCell = null;   // For Range Select {id, field, index}
        let isEditing = false;

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', async () => {
            // 1. Fetch Data
            await loadTasks();

            // 2. Setup Resizer
            setupResizer();

            // 3. Setup File Upload
            document.getElementById('file-upload').addEventListener('change', uploadSchedule);

            // 4. Keyboard Shortcuts for Selection & Clipboard
            document.addEventListener('keydown', handleGlobalKeydown);

            // 5. Grid Selection Listeners (Delegated)
            const gridBody = document.getElementById('grid-body');
            gridBody.addEventListener('mousedown', handleGridMouseDown);
            gridBody.addEventListener('dblclick', handleGridDoubleClick);
        });

        async function loadTasks() {
            try {
                // Use server-side data if available (passed via Jinja)
                if (tasks && tasks.length > 0) {
                    tasks = tasks.map(t => {
                        const parseDate = (d) => {
                            if (!d) return new Date();
                            const date = new Date(d);
                            return isNaN(date.getTime()) ? new Date() : date;
                        };
                        t.start = parseDate(t.start);
                        t.end = parseDate(t.end);
                        if (t.style && typeof t.style === 'string') {
                            try { t._style = JSON.parse(t.style); } catch (e) { }
                        }
                        return t;
                    });
                    renderGrid();
                    renderGantt();
                    return;
                }

                // Fallback catch-all (usually not needed if Jinja works)
                const res = await fetch(`/api/projects/${projectId}/activities`);
                if (!res.ok) throw new Error("Error loading");
                const data = await res.json();
                tasks = data.map(t => {
                    t.start = new Date(t.start);
                    t.end = new Date(t.end);
                    if (t.style && typeof t.style === 'string') {
                        try { t._style = JSON.parse(t.style); } catch (e) { }
                    }
                    return t;
                });
                renderGrid();
                renderGantt();
            } catch (e) { console.error(e); }
        }

        function renderGantt(viewMode = 'Week') {
            const svgElement = document.getElementById('gantt-target');
            if (!svgElement) return;
            svgElement.innerHTML = '';

            const ganttTasks = tasks.map(t => ({
                id: t.id,
                name: t.name,
                start: formatDateInput(t.start),
                end: formatDateInput(t.end),
                progress: t.progress,
                dependencies: t.dependencies,
                custom_class: t._style && t._style.fill ? `custom-fill-${t.id}` : ''
            }));

            updateDynamicCSS();

            try {
                if (ganttTasks.length === 0) {
                    document.getElementById('chart-area').innerHTML = '<div class="text-gray-400 p-10 text-center">No hay tareas para mostrar</div>';
                    return;
                }

                gantt = new Gantt("#gantt-target", ganttTasks, {
                    header_height: 50,
                    column_width: 30,
                    step: 24,
                    view_modes: ['Quarter Day', 'Half Day', 'Day', 'Week', 'Month'],
                    bar_height: 20,
                    bar_corner_radius: 3,
                    arrow_curve: 5,
                    padding: 18,
                    view_mode: viewMode,
                    date_format: 'YYYY-MM-DD',
                    language: 'es',
                    on_date_change: (task, start, end) => {
                        updateTaskDate(task.id, start, end);
                    },
                    on_click: (task) => {
                        // Optional: Sync selection
                    },
                    on_view_change: () => {
                        syncScrolls();
                        drawTodayLine();
                    }
                });

                setTimeout(drawTodayLine, 100);

            } catch (e) {
                console.error("Gantt Render Error:", e);
            }

            // Bind Scroll Sync
            const gridDiv = document.getElementById('tasks-grid');
            const chartDiv = document.getElementById('chart-area');
            if (chartDiv && gridDiv) {
                chartDiv.onscroll = () => gridDiv.scrollTop = chartDiv.scrollTop;
                gridDiv.onscroll = () => chartDiv.scrollTop = gridDiv.scrollTop;
            }
        }

        function updateDynamicCSS() {
            let styleEl = document.getElementById('dynamic-gantt-styles');
            if (!styleEl) {
                styleEl = document.createElement('style');
                styleEl.id = 'dynamic-gantt-styles';
                document.head.appendChild(styleEl);
            }
            let css = '';
            tasks.forEach(t => {
                if (t._style && t._style.fill) {
                    css += `.custom-fill-${t.id} .bar-group .bar { fill: ${t._style.fill} !important; } .custom-fill-${t.id} .bar-group .bar-progress { fill: #00000033 !important; }`;
                }
            });
            styleEl.textContent = css;
        }

        // --- TODAY LINE LOGIC ---
        function drawTodayLine() {
            const svg = document.getElementById('gantt-target');
            if (!svg || !gantt) return;

            // Remove existing
            const existing = svg.querySelector('.today-line');
            if (existing) existing.remove();

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Helper to find X. Frappe doesn't expose public API easily, 
            // but we can infer from the time scale.
            // x = (date - start) / (end - start) * width
            // Or rely on tasks?
            // HACK: Use the library's internal date mapping if possible
            // Re-use logic from bar positioning? 
            // Better: Iterate through the rendered .tick elements? No.

            // Let's use the 'gantt_start' and 'gantt_end' from the gantt object logic
            // Frappe 0.6.1 usually sets these on the instance.

            if (!gantt.gantt_start || !gantt.gantt_end) return;

            const totalDuration = gantt.gantt_end - gantt.gantt_start;
            const progress = (today - gantt.gantt_start) / totalDuration;

            if (progress < 0 || progress > 1) return; // Today is out of view

            // Width of the date area
            // SVG width usually includes padding?
            // The library renders bars in a group.
            // Let's assume linear mapping over the SVG width (or the scrollable area width?)
            // Actually, Frappe sets SVG width explicitly.
            const svgWidth = svg.getAttribute('width');
            const svgHeight = svg.getAttribute('height');

            const x = progress * svgWidth;

            // Create Line
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x);
            line.setAttribute('y1', 0);
            line.setAttribute('x2', x);
            line.setAttribute('y2', svgHeight);
            line.classList.add('today-line');

            svg.appendChild(line);
        }

        // --- GRID RENDERING (Optimized for Interaction) ---
        // State for collapsed parents
        let collapsedTasks = new Set();

        function toggleCollapse(index) {
            const parent = tasks[index];
            if (!parent) return;

            if (collapsedTasks.has(parent.id)) {
                collapsedTasks.delete(parent.id);
            } else {
                collapsedTasks.add(parent.id);
            }
            renderGrid();
            // Optional: Filter tasks passed to Gantt chart to match grid visibility
            // For now, let's just update grid. Chart might show all or we need to filter there too.
            renderGantt();
        }

        function renderGrid() {
            const tbody = document.getElementById('grid-body');
            tbody.innerHTML = '';

            const isSummary = (index) => {
                if (index >= tasks.length - 1) return false;
                const c = (tasks[index]._style && tasks[index]._style.indent) || 0;
                const n = (tasks[index + 1]._style && tasks[index + 1]._style.indent) || 0;
                return n > c;
            };

            // Helper to determine visibility based on collapsed parents
            // We need to know if any ancestor is collapsed
            // This is O(N^2) or O(N*Depth) in naive approach. 
            // Linear scan with stack is better.

            let visible = true;
            let collapsedLevel = -1; // -1 means no ancestor is collapsed

            tasks.forEach((task, index) => {
                let indent = (task._style && task._style.indent) ? task._style.indent : 0;

                // Visibility Check
                if (collapsedLevel !== -1) {
                    // We are inside a collapsed block
                    if (indent > collapsedLevel) {
                        return; // Skip rendering (hidden)
                    } else {
                        // We exited the block
                        collapsedLevel = -1;
                    }
                }

                // Parent Check
                const isParent = isSummary(index);

                // Update Collapse State Logic for *next* iterations
                if (isParent && collapsedTasks.has(task.id)) {
                    if (collapsedLevel === -1) {
                        collapsedLevel = indent;
                    }
                }

                const tr = document.createElement('tr');
                tr.dataset.id = task.id;
                tr.dataset.index = index;

                // Style Logic
                if (isParent) {
                    tr.style.fontWeight = 'bold';
                    tr.classList.add('summary-task');
                }
                if (task._style) applyRowStyle(tr, task._style);

                tr.style.height = '38px';

                // Toggle Icon
                let toggleHtml = '';
                if (isParent) {
                    const isCollapsed = collapsedTasks.has(task.id);
                    const icon = isCollapsed ? 'fa-caret-right' : 'fa-caret-down';
                    toggleHtml = `<i class="fas ${icon} toggle-icon" onclick="toggleCollapse(${index})"></i>`;
                } else {
                    toggleHtml = `<span class="toggle-icon"></span>`; // Spacer
                }

                // Helper to render cell
                tr.innerHTML = `
                    <td class="text-center text-gray-500 text-xs">${index + 1}</td>
                    
                    <!-- NAME -->
                    <td class="grid-cell" data-field="name" data-id="${task.id}">
                        <div style="display: flex; align-items: center; height:100%">
                            <span class="wbs-indent" style="width: ${indent * 20}px; flex-shrink: 0;"></span>
                            ${toggleHtml}
                            <input class="cell-input" value="${task.name}" readonly>
                        </div>
                    </td>
                    
                    <!-- CONTRACTOR -->
                    <td class="grid-cell" data-field="contractor" data-id="${task.id}">
                        <input class="cell-input" value="${task.contractor || ''}" readonly>
                    </td>
                    
                    <!-- DURATION -->
                    <td class="text-center text-xs text-gray-800" style="vertical-align: middle;">
                         ${task.duration || (diffDays(task.start, task.end) + ' d')}
                    </td>
                    
                    <!-- START -->
                    <td class="grid-cell" data-field="start" data-id="${task.id}">
                        <input type="date" class="cell-input" value="${formatDateInput(task.start)}" readonly>
                    </td>
                    
                    <!-- END -->
                    <td class="grid-cell" data-field="end" data-id="${task.id}">
                        <input type="date" class="cell-input" value="${formatDateInput(task.end)}" readonly>
                    </td>
                    
                    <!-- PROGRESS -->
                    <td class="grid-cell text-center" data-field="progress" data-id="${task.id}">
                         <input type="number" class="cell-input text-center" value="${task.progress}" readonly>
                    </td>
                `;
                tbody.appendChild(tr);
            });

            // Re-apply selection visuals
            renderSelection();
        }

        // --- INTERACTION HANDLERS ---

        function handleGridMouseDown(e) {
            // Find Cell
            const cell = e.target.closest('.grid-cell');
            if (!cell) return;

            // If currently editing another cell, commit it first? 
            // Blur event usually handles commit, but click might happen before blur finishes?
            // Let blur handle logic.

            const id = cell.dataset.id;
            const field = cell.dataset.field;
            const index = parseInt(cell.closest('tr').dataset.index);

            if (isEditing) {
                // If we click inside the SAME cell while editing, do nothing (allow text selection)
                if (cell.classList.contains('editing')) {
                    return; // Let native behavior happen
                }
                // Else, stop editing previous
                finishEditing(); // Helper to clear editing state
            }

            // Selection Logic
            if (e.ctrlKey) {
                toggleSelectCell(id, field);
            } else if (e.shiftKey && lastSelectedCell) {
                selectRange(lastSelectedCell.index, index, lastSelectedCell.field, field);
            } else {
                // Single Select
                selectedCells.clear();
                selectCell(id, field);
            }

            lastSelectedCell = { id, field, index };
            renderSelection();
        }

        function handleGridDoubleClick(e) {
            const cell = e.target.closest('.grid-cell');
            if (!cell) return;

            startEditing(cell);
        }

        function toggleSelectCell(id, field) {
            const key = `${id}:${field}`;
            if (selectedCells.has(key)) selectedCells.delete(key);
            else selectedCells.add(key);
        }

        function selectCell(id, field) {
            selectedCells.add(`${id}:${field}`);
        }

        function selectRange(idx1, idx2, field1, field2) {
            // Simplification: Select rectangular block
            // Need to know column order
            const cols = ['name', 'contractor', 'start', 'end', 'progress'];
            const c1 = cols.indexOf(field1);
            const c2 = cols.indexOf(field2);

            if (c1 === -1 || c2 === -1) return;

            const startRow = Math.min(idx1, idx2);
            const endRow = Math.max(idx1, idx2);
            const startCol = Math.min(c1, c2);
            const endCol = Math.max(c1, c2);

            selectedCells.clear();

            for (let i = startRow; i <= endRow; i++) {
                const t = tasks[i];
                for (let j = startCol; j <= endCol; j++) {
                    selectedCells.add(`${t.id}:${cols[j]}`);
                }
            }
        }

        function renderSelection() {
            // Clear all visual
            document.querySelectorAll('.grid-cell.selected').forEach(el => el.classList.remove('selected'));

            selectedCells.forEach(key => {
                const [id, field] = key.split(':');
                const cell = document.querySelector(`.grid-cell[data-id="${id}"][data-field="${field}"]`);
                if (cell) cell.classList.add('selected');
            });
        }

        // --- EDITING LOGIC ---
        let currentEditCell = null;

        function startEditing(cell) {
            if (isEditing) finishEditing();

            isEditing = true;
            currentEditCell = cell;
            cell.classList.add('editing');

            const input = cell.querySelector('input');
            if (input) {
                input.readOnly = false;
                input.focus();
                // input.select(); // Optional: select all text

                // Bind blur to save
                input.onblur = () => {
                    // Commit changes
                    const id = cell.dataset.id;
                    const field = cell.dataset.field;
                    updateField(id, field, input.value); // Existing server update fn
                    finishEditing();
                };

                // Bind Enter to save
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        input.blur();
                    }
                }
            }
        }

        function finishEditing() {
            if (!currentEditCell) return;
            const input = currentEditCell.querySelector('input');
            if (input) input.readOnly = true;
            currentEditCell.classList.remove('editing');

            // Cleanup events
            if (input) {
                input.onblur = null;
                input.onkeydown = null;
            }

            isEditing = false;
            currentEditCell = null;
        }

        // --- CLIPBOARD ---
        async function handleGlobalKeydown(e) {
            if (isEditing) return; // Allow normal keys in edit mode

            if (e.ctrlKey && e.key === 'c') {
                e.preventDefault();
                copySelection();
            } else if (e.ctrlKey && e.key === 'v') {
                e.preventDefault();
                pasteSelection();
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                deleteSelection();
            }
        }

        function copySelection() {
            if (selectedCells.size === 0) return;

            // We need to order the data to make a nice table string
            // Group by Row Index
            const rows = {}; // index -> { colIndex -> value }
            const cols = ['name', 'contractor', 'start', 'end', 'progress'];

            selectedCells.forEach(key => {
                const [id, field] = key.split(':');
                const task = tasks.find(t => t.id === id);
                if (!task) return;
                const idx = tasks.indexOf(task);
                const colIdx = cols.indexOf(field);

                if (!rows[idx]) rows[idx] = {};

                let val = task[field];
                if (field === 'start' || field === 'end') val = formatDateInput(val);
                rows[idx][colIdx] = val;
            });

            // Convert to string
            const sortedRowIndices = Object.keys(rows).sort((a, b) => a - b);
            if (sortedRowIndices.length === 0) return;

            // Normalize columns (smallest col index in selection)
            // Actually, usually clipboard is just the rect.
            // Let's just output lines.

            let text = "";
            sortedRowIndices.forEach((rIdx, i) => {
                const rowData = rows[rIdx];
                const sortedCols = Object.keys(rowData).sort((a, b) => a - b);
                const line = sortedCols.map(c => rowData[c]).join('\t');
                text += line + (i < sortedRowIndices.length - 1 ? '\n' : '');
            });

            navigator.clipboard.writeText(text).then(() => {
                // Visual feedback?
                console.log("Copied to clipboard");
            });
        }

        async function pasteSelection() {
            if (selectedCells.size === 0) return;

            // Paste starting at the "Anchor" (first selected cell)
            // Or if range selected, maybe restrict? 
            // Standard Excel: If 1 cell selected, paste expands. If range selected, paste repeats or fits.
            // Let's implement: Paste expands from TOP-LEFT of selection.

            // Find Top-Left
            const cols = ['name', 'contractor', 'start', 'end', 'progress'];
            let minRow = Infinity;
            let minCol = Infinity;

            selectedCells.forEach(key => {
                const [id, field] = key.split(':');
                const t = tasks.find(x => x.id === id);
                const r = tasks.indexOf(t);
                const c = cols.indexOf(field);
                if (r < minRow) minRow = r;
                if (c < minCol) minCol = c;
            });

            if (minRow === Infinity) return;

            try {
                const text = await navigator.clipboard.readText();
                const lines = text.split(/\r?\n/);

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i];
                    if (!line) continue;
                    const vals = line.split('\t');

                    const targetRowIdx = minRow + i;
                    if (targetRowIdx >= tasks.length) break; // Out of bounds

                    const task = tasks[targetRowIdx];

                    for (let j = 0; j < vals.length; j++) {
                        const targetColIdx = minCol + j;
                        if (targetColIdx >= cols.length) break;

                        const field = cols[targetColIdx];
                        const val = vals[j];

                        // Update Data
                        updateField(task.id, field, val); // Server update
                        // Local update usually handled in updateField but we might want batch update?
                        // updateField re-renders Gantt/Grid. If we do 50 pastes, 50 re-renders is bad.
                        // We should suppress re-render until end.

                        // Optimize: Manually update local cache, then Render ONCE
                    }
                }

                // Force Reload after bulk
                setTimeout(() => {
                    renderGrid();
                    renderGantt(gantt ? gantt.options.view_mode : 'Day');
                }, 500);

            } catch (e) {
                console.error("Paste failed", e);
            }
        }

        function deleteSelection() {
            if (!confirm("¿Borrar contenido de celdas seleccionadas?")) return;

            selectedCells.forEach(key => {
                const [id, field] = key.split(':');
                updateField(id, field, ""); // Clear value
            });
        }

        // --- EXISTING FNS (Modified to prevent conflict) ---
        // updateField needs to NOT call full render if we are just blurring?
        // Actually full render is fine for valid data consistency.

        // ... Load, ApplyStyle, AddTask ... need to ensure they don't break selection state
        // Re-rendering grid clears selection DOM, so renderGrid calls renderSelection() at end.

        // Also update renderGantt to call drawTodayLine()

        // --- STYLING LOGIC ---
        async function applyStyle(key, value) {
            // Resolve IDs from Row Selection OR Grid Selection
            const idsToUpdate = new Set(selectedTaskIds);

            selectedCells.forEach(k => {
                const [id, field] = k.split(':');
                idsToUpdate.add(id);
            });

            if (idsToUpdate.size === 0) return alert("Selecciona una tarea o celdas primero.");

            const updates = [];

            idsToUpdate.forEach(id => {
                const task = tasks.find(t => t.id === id);
                if (!task) return;

                if (!task._style) task._style = {};
                task._style[key] = value;

                // Optimistically update
                updates.push(saveTaskStyle(id, task._style));
            });

            await Promise.all(updates);
            renderGrid();
            renderGantt(gantt ? gantt.options.view_mode : 'Day');
        }

        async function toggleStyle(key) {
            // Resolve IDs
            const idsToUpdate = new Set(selectedTaskIds);
            selectedCells.forEach(k => { const [id] = k.split(':'); idsToUpdate.add(id); });

            if (idsToUpdate.size === 0) return;

            const id = Array.from(idsToUpdate)[0]; // Toggle based on first
            const task = tasks.find(t => t.id === id);
            const current = task._style ? task._style[key] : false;
            applyStyle(key, !current);
        }

        async function saveTaskStyle(id, styleObj) {
            try {
                await fetch(`/api/activities/${id}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ style: JSON.stringify(styleObj) })
                });
            } catch (e) { console.error(e); }
        }

        // --- DATA EDITING ---
        async function updateField(id, field, value) {
            const task = tasks.find(t => t.id === id);
            if (!task) return;

            // Local update
            if (field === 'start' || field === 'end') value = value; // logic handled in date change
            else task[field] = value;

            // Server Update
            const payload = {};
            payload[field] = value;

            await fetch(`/api/activities/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (field === 'start' || field === 'end' || field === 'name') renderGantt(gantt.options.view_mode);
        }

        async function updateTaskDate(id, start, end) {
            await updateField(id, 'start', start.toISOString().split('T')[0]);
            await updateField(id, 'end', end.toISOString().split('T')[0]);

            // Update Local array
            const t = tasks.find(x => x.id == id);
            if (t) { t.start = start; t.end = end; }
            renderGrid(); // Refresh grid dates
        }

        // --- CRUD ACTIONS ---
        async function addTask() {
            const newId = "new-" + Date.now(); // Temp ID
            const newTask = {
                id: newId,
                name: "Nueva Tarea",
                start: new Date(),
                end: new Date(Date.now() + 86400000), // +1 day
                progress: 0,
                dependencies: "",
                contractor: "",
                _style: { indent: 0 }
            };

            // Insert after selection or at end
            if (selectedTaskIds.size > 0) {
                const lastSelectedId = Array.from(selectedTaskIds).pop();
                const idx = tasks.findIndex(t => t.id === lastSelectedId);
                tasks.splice(idx + 1, 0, newTask);
            } else {
                tasks.push(newTask);
            }

            // Persist (Create on backend usually, but for now just local update until Save)
            // Ideally we call POST /api/activities
            try {
                await fetch(`/api/projects/${projectId}/activities`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newTask)
                });
            } catch (e) { console.error("Error creating task", e); } // Silently fail/continue

            renderGrid();
            renderGantt(gantt ? gantt.options.view_mode : 'Day');
        }

        async function deleteTask() {
            if (selectedTaskIds.size === 0) return alert("Selecciona tareas para eliminar");
            if (!confirm("¿Eliminar tareas seleccionadas?")) return;

            const ids = Array.from(selectedTaskIds);

            // Remove from backend
            for (const id of ids) {
                if (!id.startsWith("new-")) { // Only delete if persisted
                    await fetch(`/api/activities/${id}`, { method: 'DELETE' });
                }
            }

            tasks = tasks.filter(t => !selectedTaskIds.has(t.id));
            selectedTaskIds.clear();
            renderGrid();
            renderGantt(gantt ? gantt.options.view_mode : 'Day');
        }

        async function moveTask(direction) {
            if (selectedTaskIds.size !== 1) return; // Only move single row for now
            const id = Array.from(selectedTaskIds)[0];
            const idx = tasks.findIndex(t => t.id === id);

            if (direction === -1 && idx > 0) {
                // Swap with prev
                [tasks[idx], tasks[idx - 1]] = [tasks[idx - 1], tasks[idx]];
            } else if (direction === 1 && idx < tasks.length - 1) {
                // Swap with next
                [tasks[idx], tasks[idx + 1]] = [tasks[idx + 1], tasks[idx]];
            }
            renderGrid();
            renderGantt(gantt ? gantt.options.view_mode : 'Day');
        }

        // --- SELECTION LOGIC ---
        function selectTask(id, e) {
            if (!clickedIdIsTask(id)) return;

            if (e.ctrlKey || e.metaKey) {
                if (selectedTaskIds.has(id)) selectedTaskIds.delete(id);
                else selectedTaskIds.add(id);
            } else if (e.shiftKey) {
                // Range selection (simple implementation)
                // TODO: Find index range
                selectedTaskIds.add(id);
            } else {
                selectedTaskIds.clear();
                selectedTaskIds.add(id);
            }
            renderGrid(); // Re-render to show highlight
        }
        function clickedIdIsTask(id) { return tasks.some(t => t.id === id); }

        function handleKeySelection(e) {
            if (e.key === 'Escape') {
                selectedTaskIds.clear();
                renderGrid();
            }
        }

        // --- UTILS ---
        function diffDays(d1, d2) {
            return Math.ceil((d2 - d1) / (1000 * 60 * 60 * 24));
        }
        function formatDateInput(date) {
            if (!date) return '';
            return date.toISOString().split('T')[0];
        }

        function changeView(mode) {
            renderGantt(mode);
        }

        function syncScrolls() {
            const gridDiv = document.getElementById('tasks-grid');
            const chartDiv = document.getElementById('chart-area');
            if (gridDiv && chartDiv) {
                gridDiv.scrollTop = chartDiv.scrollTop;
            }
        }

        // --- ACTIONS ---
        async function indentTask(direction) {
            // Resolve IDs
            const idsToUpdate = new Set(selectedTaskIds);
            selectedCells.forEach(k => { const [id] = k.split(':'); idsToUpdate.add(id); });

            if (idsToUpdate.size === 0) return;

            const updates = [];
            idsToUpdate.forEach(id => {
                const t = tasks.find(x => x.id === id);
                if (!t) return;

                // Use style.indent level
                if (!t._style) t._style = {};
                let level = t._style.indent || 0;
                level += direction;
                if (level < 0) level = 0;
                t._style.indent = level;

                updates.push(saveTaskStyle(id, t._style));
            });

            await Promise.all(updates);
            renderGrid();
        }

        async function addLink() {
            // Link selected tasks sequentially
            const selected = Array.from(new Set([...selectedTaskIds, ...Array.from(selectedCells).map(k => k.split(':')[0])]));
            if (selected.length < 2) return alert("Selecciona al menos 2 tareas para vincular");

            for (let i = 1; i < selected.length; i++) {
                const predecessorId = selected[i - 1];
                const successorId = selected[i];
                const successor = tasks.find(t => t.id === successorId);

                // Add dependency
                let deps = successor.dependencies ? successor.dependencies.split(',') : [];
                if (!deps.includes(predecessorId)) {
                    deps.push(predecessorId);
                    successor.dependencies = deps.join(',');
                    await updateField(successorId, 'predecessors', successor.dependencies);
                }
            }
            renderGantt(gantt.options.view_mode);
        }

        async function removeLink() {
            const selected = Array.from(new Set([...selectedTaskIds, ...Array.from(selectedCells).map(k => k.split(':')[0])]));
            if (selected.length === 0) return alert("Selecciona tareas para desvincular");

            for (const id of selected) {
                const t = tasks.find(x => x.id === id);
                if (t && t.dependencies) {
                    t.dependencies = "";
                    await updateField(id, 'predecessors', "");
                }
            }
            renderGantt(gantt.options.view_mode);
        }



        // --- RESIZER ---
        function setupResizer() {
            const resizer = document.getElementById('resizer');
            const leftPane = document.getElementById('tasks-grid');
            let x = 0;
            let w = 0;

            const mouseDownHandler = function (e) {
                x = e.clientX;
                const rect = leftPane.getBoundingClientRect();
                w = rect.width;
                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);
                resizer.classList.add('resizing');
            };

            const mouseMoveHandler = function (e) {
                const dx = e.clientX - x;
                leftPane.style.width = `${w + dx}px`;
                document.documentElement.style.setProperty('--grid-width', `${w + dx}px`);
                resizer.style.left = `${w + dx}px`;
            };

            const mouseUpHandler = function () {
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('mouseup', mouseUpHandler);
                resizer.classList.remove('resizing');
            };

            resizer.addEventListener('mousedown', mouseDownHandler);
        }

        async function uploadSchedule(e) {
            const file = e.target.files[0];
            if (!file) return;

            const formData = new FormData();
            formData.append('file', file);

            // Show loading by changing button text temporarily
            const btn = document.querySelector('button[onclick*="file-upload"]');
            const originalContent = btn ? btn.innerHTML : '';
            if (btn) {
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Procesando...';
                btn.disabled = true;
            }

            try {
                const res = await fetch(`/api/projects/${projectId}/schedule`, {
                    method: 'POST',
                    body: formData
                });

                const data = await res.json();

                if (!res.ok) {
                    throw new Error(data.detail || "Error al subir");
                }

                alert("Importación exitosa. La página se recargará.");
                location.reload();
            } catch (err) {
                console.error(err);
                alert("Aviso: " + err.message);
            } finally {
                if (btn) {
                    btn.innerHTML = originalContent;
                    btn.disabled = false;
                }
                // Reset input
                e.target.value = '';
            }
        }

    </script>
</body>

</html>