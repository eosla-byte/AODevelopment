<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ project.name }} - Scheduling Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --row-height: 32px;
            --header-height: 60px;
            --col-id-width: 40px;
            --col-name-width: 300px;
            --col-start-width: 100px;
            --col-end-width: 100px;
            --col-dur-width: 80px;
            --col-pct-width: 60px;

            --sticky-left-total: calc(40px + 300px + 100px + 100px + 80px + 60px);
            /* Adjust based on visible cols */

            --grid-border: 1px solid #e5e7eb;
            --bg-header: #f9fafb;
        }

        * {
            box-sizing: border-box;
        }

        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            font-size: 13px;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #toolbar {
            height: 48px;
            flex-shrink: 0;
            border-bottom: var(--grid-border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 8px;
            z-index: 100;
            background: white;
        }

        /* --- THE MASTER SCROLL CONTAINER --- */
        #master-scroll {
            flex: 1;
            overflow: auto;
            /* The ONLY scrollbar */
            position: relative;
            background: white;
        }

        /* --- THE GIANT GRID --- */
        #main-table {
            border-collapse: separate;
            /* Required for sticky */
            border-spacing: 0;
            table-layout: fixed;
            width: max-content;
            /* Allows horizontal growth */
        }

        /* Headers */
        thead th {
            position: sticky;
            top: 0;
            z-index: 40;
            height: var(--header-height);
            background: var(--bg-header);
            border-bottom: var(--grid-border);
            border-right: var(--grid-border);
            vertical-align: middle;
            /* Center vertically specifically for Timeline */
        }

        /* Fixed Columns (Left) */
        .sticky-col {
            position: sticky;
            z-index: 30;
            background: white;
            /* Cover Gantt bars sliding under */
            left: 0;
            /* JS updates this for subsequent cols */
        }

        /* Corner Headers (Top-Left) - The "Pivot" */
        thead th.sticky-col {
            z-index: 50;
            /* Above everything */
            background: #f3f4f6;
        }

        /* Cells */
        td {
            height: var(--row-height);
            border-bottom: var(--grid-border);
            border-right: var(--grid-border);
            padding: 0 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Timeline Header Cell */
        #timeline-header-cell {
            padding: 0;
            margin: 0;
            background: white;
        }

        /* Resizers */
        .resizer {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            cursor: col-resize;
            z-index: 60;
        }

        .resizer:hover {
            background: #3b82f6;
        }

        /* Row Highlights */
        tr:hover td {
            background-color: #f3f9ff;
        }

        /* Gantt Cell */
        .gantt-cell {
            padding: 0;
            margin: 0;
            vertical-align: top;
            position: relative;
        }
    </style>
</head>

<body>
    <div id="app">
        <!-- TOOLBAR -->
        <div id="toolbar">
            <h1 class="font-bold mr-4">{{ project.name }}</h1>
            <button class="bg-gray-100 hover:bg-gray-200 p-1.5 rounded" onclick="AO.Gantt.zoomOut()"><i
                    class="fas fa-minus"></i></button>
            <span id="zoom-label" class="w-16 text-center font-mono text-xs">WEEK</span>
            <button class="bg-gray-100 hover:bg-gray-200 p-1.5 rounded" onclick="AO.Gantt.zoomIn()"><i
                    class="fas fa-plus"></i></button>
        </div>

        <!-- MASTER SCROLL -->
        <div id="master-scroll">
            <table id="main-table">
                <thead>
                    <tr id="header-row">
                        <!-- LEFT COLUMNS (JS Generated) -->
                        <!-- RIGHT TIMELINE (Single Giant TH) -->
                        <th id="timeline-header-cell">
                            <svg id="timeline-svg" height="60" width="100%"></svg>
                        </th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <!-- ROWS (JS Generated) -->
                </tbody>
            </table>

            <!-- GANTT OVERLAY (Absolute, for Bars) -->
            <!-- We render bars inside the last TD of each row or a separate overlay? 
                 Better: Render bars in an SVG inside the last TD of *each row*? No, too many SVGs.
                 Better: One Giant SVG overlaying the right side? 
                 Solution: The last column is the "Gantt Column". 
            -->
        </div>
    </div>

    <script type="module">
        // --- CONFIG ---
        const Config = {
            columns: [
                { id: 'wbs', label: 'ID', width: 60, align: 'left' }, // Changed ID to WBS
                { id: 'name', label: 'Tarea', width: 300, align: 'left', editable: true },
                { id: 'start', label: 'Inicio', width: 100, align: 'center', editable: true },
                { id: 'end', label: 'Fin', width: 100, align: 'center', editable: true },
                { id: 'progress', label: '%', width: 60, align: 'center', editable: true } // Mapped "pct" to "progress"
            ],
            rowHeight: 32,
            headerHeight: 60
        };

        const State = {
            tasks: [], // includes level, collapsed, isSummary
            zoom: 'WEEK',
            pxPerMin: 0.01,
            startDate: new Date(),
            totalWidth: 2000,
            selectedIds: new Set(),
            lastSelectedId: null
        };

        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("AO Gantt: Starting...");
            try {
                const serverTasks = {{ tasks | tojson | safe
            }};
        console.log("AO Gantt: Tasks loaded:", serverTasks ? serverTasks.length : 0);

        if (!serverTasks || !Array.isArray(serverTasks)) {
            console.error("AO Gantt: Invalid tasks data", serverTasks);
            return;
        }

        // Post-process server tasks
        State.tasks = serverTasks.map((t, i) => ({
            ...t,
            level: t.level || 0,
            collapsed: false,
            isSummary: false, // Calculated later
            childrenIds: [],
            parentId: null,
            orderIndex: i
        }));

        initTimeEngine();
        HierarchyEngine.recalculate(State.tasks);
        render();

        // Global Keys
        document.addEventListener('keydown', handleGlobalKeys);
        console.log("AO Gantt: Render complete");
            } catch (e) {
            console.error("AO Gantt: Crash during init", e);
            alert("Error loading Gantt: " + e.message);
        }
        });

        // --- HIERARCHY ENGINE ---
        const HierarchyEngine = {
            recalculate(tasks) {
                // 1. Reset
                tasks.forEach((t, i) => {
                    t.isSummary = false;
                    t.childrenIds = [];
                    t.parentId = null;
                    t.wbs = ''; // Re-calc logic if needed, but we trust level for now
                    t.orderIndex = i;
                });

                // 2. Build Tree based on linear list
                // Stack of "active parents" at each level
                // Level 0 parent at stack[0]...
                const parentStack = [];

                tasks.forEach(task => {
                    const level = task.level;

                    // Maintain stack such that stack[L] is the last task seen at Level L
                    parentStack[level] = task;

                    // Parent is at level - 1
                    if (level > 0 && parentStack[level - 1]) {
                        const parent = parentStack[level - 1];
                        parent.childrenIds.push(task.id);
                        parent.isSummary = true;
                        task.parentId = parent.id;
                    }

                    // Clear deeper levels from stack as they are now closed
                    for (let l = level + 1; l < parentStack.length; l++) {
                        parentStack[l] = null;
                    }
                });
            },

            toggleCollapse(taskId) {
                const task = State.tasks.find(t => t.id === taskId);
                if (task && task.isSummary) {
                    task.collapsed = !task.collapsed;
                    render();
                }
            },

            indent() {
                const toModify = new Set();
                State.tasks.forEach(t => {
                    if (State.selectedIds.has(t.id)) {
                        toModify.add(t);
                        // Include subtree
                        const subtree = this.getSubtree(t);
                        subtree.forEach(child => toModify.add(child));
                    }
                });

                // Validate: Can we indent? (Prev sibling must exist)
                // We'll skip validation for brevity/ux fluidity (Project usually allows it and auto-parents)

                toModify.forEach(t => {
                    t.level += 1;
                });

                this.recalculate(State.tasks);
                render();
            },

            outdent() {
                const toModify = new Set();
                State.tasks.forEach(t => {
                    if (State.selectedIds.has(t.id)) {
                        toModify.add(t);
                        const subtree = this.getSubtree(t);
                        subtree.forEach(child => toModify.add(child));
                    }
                });

                toModify.forEach(t => {
                    if (t.level > 0) t.level -= 1;
                });

                this.recalculate(State.tasks);
                render();
            },

            getSubtree(parent) {
                const results = [];
                const idx = parent.orderIndex;
                for (let i = idx + 1; i < State.tasks.length; i++) {
                    const t = State.tasks[i];
                    if (t.level > parent.level) {
                        results.push(t);
                    } else {
                        break;
                    }
                }
                return results;
            }
        };

        // --- INTERACTION ---
        function handleGlobalKeys(e) {
            // Indent/Outdent
            if (e.altKey && e.shiftKey) {
                if (e.key === 'ArrowRight') {
                    HierarchyEngine.indent();
                    e.preventDefault();
                } else if (e.key === 'ArrowLeft') {
                    HierarchyEngine.outdent();
                    e.preventDefault();
                }
            }
        }

        function selectRow(task, mode) { // mode: 'single', 'multi', 'range'
            if (mode === 'single') {
                State.selectedIds.clear();
                State.selectedIds.add(task.id);
            } else if (mode === 'multi') {
                if (State.selectedIds.has(task.id)) State.selectedIds.delete(task.id);
                else State.selectedIds.add(task.id);
            } else {
                State.selectedIds.add(task.id);
            }
            State.lastSelectedId = task.id;
            render();
        }

        // --- RENDERERS ---
        function render() {
            renderHeader();
            renderBody();
        }

        function renderHeader() {
            const tr = document.getElementById('header-row');
            const timelineTh = document.getElementById('timeline-header-cell');

            // Clean logic (same as before)
            Array.from(tr.children).forEach(child => {
                if (child.id !== 'timeline-header-cell') tr.removeChild(child);
            });

            let leftOffset = 0;
            Config.columns.forEach(col => {
                const th = document.createElement('th');
                th.className = 'sticky-col';
                th.innerText = col.label;
                th.style.width = col.width + 'px';
                th.style.left = leftOffset + 'px';
                th.style.minWidth = col.width + 'px';
                const resizer = document.createElement('div');
                resizer.className = 'resizer';
                resizer.onmousedown = (e) => initResize(e, col);
                th.appendChild(resizer);
                tr.insertBefore(th, timelineTh);
                leftOffset += col.width;
            });

            State.totalWidth = calculateTotalWidth();
            timelineTh.style.width = State.totalWidth + 'px';
            timelineTh.style.minWidth = State.totalWidth + 'px';
            renderTimelineTicks(document.getElementById('timeline-svg'));
        }

        function renderTimelineTicks(svg) {
            svg.innerHTML = '';
            const zoom = State.zoom;
            let tickW = 50;

            // Tier 1 (Bottom) - The detailed tick
            // Tier 2 (Top) - The grouping tick (Month/Year)

            // CONFIG BASED ON ZOOM
            let bottomTierUnit = 'd'; // d=day, w=week, m=month
            let topTierUnit = 'm';    // m=month, y=year
            let bottomStep = 1;       // 1 day, 1 week

            if (zoom === 'DAY') { tickW = 40; bottomTierUnit = 'd'; topTierUnit = 'm'; }
            else if (zoom === 'WEEK') { tickW = 60; bottomTierUnit = 'w'; topTierUnit = 'm'; }
            else if (zoom === 'MONTH') { tickW = 100; bottomTierUnit = 'm'; topTierUnit = 'y'; }

            State.pxPerMin = tickW / (bottomTierUnit === 'd' ? 1440 : (bottomTierUnit === 'w' ? 10080 : 43200));

            // We need to re-render renderHeader to apply pxPerMin changes immediately if we set it here?
            // Better: use State.pxPerMin to derive tickW, not vice versa.
            // Let's invert: 
            // tickW = duration * pxPerMin

            // REFINED APPROACH: Use current pxPerMin to determine tick placement
            // Just draw ticks starting from startDate

            let curr = new Date(State.startDate);
            let x = 0;
            const H_TOP = 25;
            const H_BOT = 35; // Total 60

            // 1. Draw Bottom Tier & Grid Lines
            while (x < State.totalWidth) {
                // Determine next date and label
                let nextDate = new Date(curr);
                let label = '';

                if (zoom === 'DAY') {
                    nextDate.setDate(curr.getDate() + 1);
                    label = curr.getDate().toString();
                    // Weekday letter?
                    const days = ['D', 'L', 'M', 'X', 'J', 'V', 'S'];
                    label = days[curr.getDay()] + ' ' + label;
                } else if (zoom === 'WEEK') {
                    nextDate.setDate(curr.getDate() + 7);
                    label = `Sem ${getWeekNumber(curr)}`;
                } else { // MONTH
                    nextDate.setMonth(curr.getMonth() + 1);
                    label = curr.toLocaleDateString('es-ES', { month: 'short' });
                }

                const w = timeToX(nextDate) - timeToX(curr);

                // Rect
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute('x', x);
                rect.setAttribute('y', 30);
                rect.setAttribute('width', w);
                rect.setAttribute('height', 30);
                rect.setAttribute('fill', 'white');
                rect.setAttribute('stroke', '#e5e7eb');
                svg.appendChild(rect);

                // Text
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute('x', x + w / 2);
                text.setAttribute('y', 50);
                text.setAttribute('text-anchor', 'middle');
                text.textContent = label;
                text.setAttribute('font-size', '11');
                text.setAttribute('fill', '#6b7280');
                svg.appendChild(text);

                curr = nextDate;
                x = timeToX(curr);
            }

            // 2. Draw Top Tier (Months/Years)
            curr = new Date(State.startDate);
            x = 0;
            // Snap to first month/year boundary for smoother look? 
            // For now, just iterate safely.

            // We need to handle "Group By" rendering. 
            // Simpler approach: Iterate by Top Unit
            // But x is linear. 

            // Let's reset curr to start
            curr = new Date(State.startDate);
            // Snap curr to start of month if zoom is day/week
            if (zoom !== 'MONTH') curr.setDate(1);
            if (zoom === 'MONTH') curr.setMonth(0); // Year start

            // Adjust starting X (might be negative if startDate is mid-month)
            // We'll just draw valid months that overlap [0, totalWidth]

            let safety = 0;
            while (x < State.totalWidth && safety < 1000) {
                safety++;
                let nextTop = new Date(curr);
                let topLabel = '';

                if (zoom === 'MONTH') {
                    nextTop.setFullYear(curr.getFullYear() + 1);
                    topLabel = curr.getFullYear();
                } else { // DAY/WEEK -> Group by Month
                    nextTop.setMonth(curr.getMonth() + 1);
                    topLabel = curr.toLocaleDateString('es-ES', { month: 'long', year: 'numeric' });
                }

                const xStart = Math.max(0, timeToX(curr));
                const xEnd = timeToX(nextTop);

                if (xEnd > 0) {
                    const w = xEnd - xStart;
                    const topRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    topRect.setAttribute('x', xStart); topRect.setAttribute('y', 0);
                    topRect.setAttribute('width', w); topRect.setAttribute('height', 30);
                    topRect.setAttribute('fill', '#f9fafb'); topRect.setAttribute('stroke', '#e5e7eb');
                    svg.appendChild(topRect);

                    const topText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    topText.setAttribute('x', xStart + 10); topText.setAttribute('y', 20);
                    topText.textContent = topLabel;
                    topText.setAttribute('font-size', '12'); topText.setAttribute('font-weight', 'bold');
                    topText.setAttribute('fill', '#374151');
                    svg.appendChild(topText);
                }

                curr = nextTop;
                if (timeToX(curr) > State.totalWidth) break;
            }
        }

        function getWeekNumber(d) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return weekNo;
        }

        function renderBody() {
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';

            // Dependency Overlay Logic
            let depSvg = document.getElementById('dependency-svg');
            const masterScroll = document.getElementById('master-scroll');
            if (!depSvg) {
                depSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                depSvg.id = 'dependency-svg';
                depSvg.style.position = 'absolute';
                depSvg.style.top = '60px';
                depSvg.style.pointerEvents = 'none';
                masterScroll.appendChild(depSvg);
            }
            depSvg.style.left = getTotalStickyWidth() + 'px';
            depSvg.style.width = State.totalWidth + 'px';
            depSvg.style.height = Math.max(State.tasks.length * 32, 500) + 'px';

            let hiddenLevel = -1;

            State.tasks.forEach(task => {
                if (hiddenLevel > -1 && task.level > hiddenLevel) return;
                if (hiddenLevel > -1 && task.level <= hiddenLevel) hiddenLevel = -1;
                if (task.isSummary && task.collapsed && hiddenLevel === -1) hiddenLevel = task.level;

                const tr = document.createElement('tr');
                if (State.selectedIds.has(task.id)) tr.style.backgroundColor = 'var(--selection-blue)'; // #eff6ff

                tr.onclick = (e) => {
                    const mode = e.ctrlKey ? 'multi' : (e.shiftKey ? 'range' : 'single');
                    selectRow(task, mode);
                };

                let leftOffset = 0;
                Config.columns.forEach(col => {
                    const td = document.createElement('td');
                    td.className = 'sticky-col';
                    td.style.left = leftOffset + 'px';
                    td.style.width = col.width + 'px';
                    td.style.minWidth = col.width + 'px';

                    if (col.id === 'name') {
                        td.style.paddingLeft = (task.level * 20 + 8) + 'px';
                        td.style.display = 'flex'; td.style.alignItems = 'center';
                        if (task.isSummary) {
                            const icon = document.createElement('i');
                            icon.className = `fas fa-caret-${task.collapsed ? 'right' : 'down'} mr-2 cursor-pointer`;
                            icon.onclick = (e) => { e.stopPropagation(); HierarchyEngine.toggleCollapse(task.id); };
                            td.appendChild(icon);
                        }
                    }

                    const span = document.createElement('span');
                    let val = task[col.id];
                    if (col.id === 'start' || col.id === 'end') val = val ? val.toString().split('T')[0] : '';
                    if (col.id === 'progress') val = Math.round(val || 0) + '%';

                    span.innerText = val || '';
                    span.style.width = "100%";
                    if (col.editable) {
                        span.contentEditable = true;
                        span.onblur = (e) => { task[col.id] = e.target.innerText; }; // Simple mock save
                        span.onclick = (e) => e.stopPropagation();
                    }
                    td.appendChild(span);
                    tr.appendChild(td);
                    leftOffset += col.width;
                });

                const ganttTd = document.createElement('td');
                ganttTd.className = 'gantt-cell';
                const barSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                barSvg.style.width = State.totalWidth + 'px';
                barSvg.style.height = '100%';
                barSvg.style.display = 'block';

                if (task.start && task.end) {
                    const x = timeToX(task.start);
                    const w = timeToX(task.end) - x;

                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

                    let barH = 20;
                    let barY = 6;
                    let barColor = '#3b82f6';
                    let barRadius = 3;

                    if (task.isSummary) {
                        barH = 12; barY = 6; barColor = '#000'; barRadius = 0;
                        // Summary Bar (Black Bracket)
                        const rect = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        // Draw bracket shape
                        // M x,y+h L x,y L x+w,y L x+w,y+h
                        const d = `M ${x},${barY + barH} L ${x},${barY} L ${x + w},${barY} L ${x + w},${barY + barH}`;
                        rect.setAttribute('d', d);
                        rect.setAttribute('fill', 'none');
                        rect.setAttribute('stroke', '#000');
                        rect.setAttribute('stroke-width', '2');
                        g.appendChild(rect);
                    } else {
                        // Standard Task Bar
                        // 1. Background (Light Blue)
                        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        bgRect.setAttribute('x', x); bgRect.setAttribute('y', barY);
                        bgRect.setAttribute('width', Math.max(w, 5)); bgRect.setAttribute('height', barH);
                        bgRect.setAttribute('fill', '#dbeafe'); // Light Blue
                        bgRect.setAttribute('rx', barRadius);
                        g.appendChild(bgRect);

                        // 2. Progress (Dark Blue)
                        const pct = parseFloat(task.progress || 0) / 100;
                        if (pct > 0) {
                            const progRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            progRect.setAttribute('x', x); progRect.setAttribute('y', barY + 4); // Slightly thinner? No, full height
                            progRect.setAttribute('y', barY);
                            progRect.setAttribute('width', Math.max(w * pct, 0));
                            progRect.setAttribute('height', barH);
                            progRect.setAttribute('fill', '#3b82f6'); // Dark Blue
                            progRect.setAttribute('rx', barRadius);
                            g.appendChild(progRect);
                        }
                    }
                    barSvg.appendChild(g);
                }
                ganttTd.appendChild(barSvg);
                tr.appendChild(ganttTd);
                tbody.appendChild(tr);
            });
        }


        function getTotalStickyWidth() { return Config.columns.reduce((sum, col) => sum + col.width, 0); }

        function initTimeEngine() {
            if (State.tasks.length > 0) {
                let min = new Date(State.tasks[0].start || new Date());
                State.tasks.forEach(t => {
                    if (t.start && new Date(t.start) < min) min = new Date(t.start);
                });
                min.setDate(min.getDate() - 15);
                State.startDate = min;
            } else { State.startDate = new Date(); }
        }
        function calculateTotalWidth() { return 3000; }
        function timeToX(dateStr) {
            const d = new Date(dateStr);
            const diffMins = (d - State.startDate) / 60000;
            return diffMins * State.pxPerMin;
        }
        function initResize(e, col) {
            e.preventDefault();
            const startX = e.clientX;
            const startW = col.width;

            const onMove = (mv) => {
                const diff = mv.clientX - startX;
                col.width = Math.max(30, startW + diff);
                render();
            };

            const onUp = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            };

            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }

        window.AO = {
            Gantt: {
                zoomIn: () => { State.pxPerMin *= 1.2; render(); },
                zoomOut: () => { State.pxPerMin *= 0.8; render(); }
            }
        };
    </script>
</body>

</html>