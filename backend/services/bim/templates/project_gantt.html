<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ project.name }} - Scheduling Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --row-height: 32px;
            --header-height: 60px;
            --col-id-width: 40px;
            --col-name-width: 300px;
            --col-start-width: 100px;
            --col-end-width: 100px;
            --col-dur-width: 80px;
            --col-pct-width: 60px;

            --sticky-left-total: calc(40px + 300px + 100px + 100px + 80px + 60px);
            /* Adjust based on visible cols */

            --grid-border: 1px solid #e5e7eb;
            --bg-header: #f9fafb;
        }

        * {
            box-sizing: border-box;
        }

        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            font-size: 13px;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #toolbar {
            height: 48px;
            flex-shrink: 0;
            border-bottom: var(--grid-border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 8px;
            z-index: 100;
            background: white;
        }

        /* --- THE MASTER SCROLL CONTAINER --- */
        #master-scroll {
            flex: 1;
            overflow: auto;
            /* The ONLY scrollbar */
            position: relative;
            background: white;
        }

        /* --- THE GIANT GRID --- */
        #main-table {
            border-collapse: separate;
            /* Required for sticky */
            border-spacing: 0;
            table-layout: fixed;
            width: max-content;
            /* Allows horizontal growth */
        }

        /* Headers */
        thead th {
            position: sticky;
            top: 0;
            z-index: 40;
            height: var(--header-height);
            background: var(--bg-header);
            border-bottom: var(--grid-border);
            border-right: var(--grid-border);
            vertical-align: middle;
            /* Center vertically specifically for Timeline */
        }

        /* Fixed Columns (Left) */
        .sticky-col {
            position: sticky;
            z-index: 30;
            background: white;
            /* Cover Gantt bars sliding under */
            left: 0;
            /* JS updates this for subsequent cols */
        }

        /* Corner Headers (Top-Left) - The "Pivot" */
        thead th.sticky-col {
            z-index: 50;
            /* Above everything */
            background: #f3f4f6;
        }

        /* Cells */
        td {
            height: var(--row-height);
            border-bottom: var(--grid-border);
            border-right: var(--grid-border);
            padding: 0 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Timeline Header Cell */
        #timeline-header-cell {
            padding: 0;
            margin: 0;
            background: white;
        }

        /* Resizers */
        .resizer {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            cursor: col-resize;
            z-index: 60;
        }

        .resizer:hover {
            background: #3b82f6;
        }

        /* Row Highlights */
        tr:hover td {
            background-color: #f3f9ff;
        }

        /* Gantt Cell */
        .gantt-cell {
            padding: 0;
            margin: 0;
            vertical-align: top;
            position: relative;
        }

        /* Grid Selection Styles */
        .selected-cell {
            background-color: rgba(59, 130, 246, 0.1) !important;
            border: 1px solid #3b82f6 !important;
        }

        .fill-handle {
            width: 8px;
            height: 8px;
            background-color: #3b82f6;
            position: absolute;
            bottom: -4px;
            right: -4px;
            cursor: crosshair;
            z-index: 10;
        }

        .selection-border-top {
            border-top: 2px solid #3b82f6 !important;
        }

        .selection-border-bottom {
            border-bottom: 2px solid #3b82f6 !important;
        }

        .selection-border-left {
            border-left: 2px solid #3b82f6 !important;
        }

        .selection-border-right {
            border-right: 2px solid #3b82f6 !important;
        }
    </style>
</head>

<body>
    <div id="app">
        <!-- TOOLBAR -->
        <div id="toolbar">
            <h1 class="font-bold mr-4">{{ project.name }}</h1>
            <button class="bg-gray-100 hover:bg-gray-200 p-1.5 rounded" onclick="AO.Gantt.zoomOut()"><i
                    class="fas fa-minus"></i></button>
            <span id="zoom-label" class="w-16 text-center font-mono text-xs">WEEK</span>
            <button class="bg-gray-100 hover:bg-gray-200 p-1.5 rounded" onclick="AO.Gantt.zoomIn()"><i
                    class="fas fa-plus"></i></button>
        </div>

        <!-- MASTER SCROLL -->
        <div id="master-scroll">
            <table id="main-table">
                <thead>
                    <tr id="header-row">
                        <!-- LEFT COLUMNS (JS Generated) -->
                        <!-- RIGHT TIMELINE (Single Giant TH) -->
                        <th id="timeline-header-cell">
                            <svg id="timeline-svg" height="60" width="100%"></svg>
                        </th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <!-- ROWS (JS Generated) -->
                </tbody>
            </table>

            <!-- GANTT OVERLAY (Absolute, for Bars) -->
            <!-- We render bars inside the last TD of each row or a separate overlay? 
                 Better: Render bars in an SVG inside the last TD of *each row*? No, too many SVGs.
                 Better: One Giant SVG overlaying the right side? 
                 Solution: The last column is the "Gantt Column". 
            -->
        </div>
    </div>

    <script type="module">
        // --- CONFIG ---
        const Config = {
            columns: [
                { id: 'contractor', label: 'Empresa', width: 150, align: 'left', editable: true }, // Replaced ID (WBS)
                { id: 'name', label: 'Tarea', width: 300, align: 'left', editable: true },
                { id: 'duration', label: 'Duración', width: 80, align: 'center', editable: true }, // New Duration
                { id: 'start', label: 'Inicio', width: 100, align: 'center', editable: true },
                { id: 'end', label: 'Fin', width: 100, align: 'center', editable: true },
                { id: 'progress', label: '%', width: 60, align: 'center', editable: true }
            ],
            rowHeight: 32,
            headerHeight: 60
        };

        const State = {
            tasks: [], // includes level, collapsed, isSummary
            zoom: 'WEEK',
            pxPerMin: 0.01,
            startDate: new Date(),
            totalWidth: 2000,
            selectedIds: new Set(),
            lastSelectedId: null,
            // Look Ahead State
            lookAheadStart: new Date(),
            lookAheadWeeks: 3,
            showLookAhead: false,
            companyColors: {},
            // Formatting & AutoSave
            autoSaveTimer: null,
            dirtyTasks: new Set(),
            // Grid Interaction
            selectedCells: new Set(), // "taskId:colId"
            activeCell: null, // {taskId, colId}
            anchorCell: null, // {taskId, colId}
            isDragging: false,
            isFilling: false,
            fillSourceRange: null // {startRow, endRow, tasks: []}
        };

        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("AO Gantt: Starting...");
            try {
                const serverTasks = {{ tasks | tojson | safe
            }};
        console.log("AO Gantt: Tasks loaded:", serverTasks ? serverTasks.length : 0);

        if (!serverTasks || !Array.isArray(serverTasks)) {
            console.error("AO Gantt: Invalid tasks data", serverTasks);
            return;
        }

        // Post-process server tasks
        State.tasks = serverTasks.map((t, i) => ({
            ...t,
            level: t.level || 0,
            collapsed: false,
            isSummary: false, // Calculated later
            childrenIds: [],
            parentId: null,
            orderIndex: i
        }));

        // Init Look Ahead defaults (Today)
        const today = new Date();
        State.lookAheadStart = new Date(today);

        // Toolbar Injection for Look Ahead
        injectToolbarControls();

        initTimeEngine();
        HierarchyEngine.recalculate(State.tasks);
        render();

        // Auto-Scroll to Today
        setTimeout(scrollToToday, 100);

        // Global Keys
        document.addEventListener('keydown', handleGlobalKeys);
        console.log("AO Gantt: Render complete");
            } catch (e) {
            console.error("AO Gantt: Crash during init", e);
            alert("Error loading Gantt: " + e.message);
        }
        });

        // --- CONTROLS INJECTION ---
        function injectToolbarControls() {
            const toolbar = document.getElementById('toolbar');

            // --- EXISTING 1: ZOOM ---
            // (Assumed existing zoom buttons are there or we leave them alone if hardcoded)

            // --- 2. SEPARATOR ---
            const sep1 = createSeparator();
            toolbar.appendChild(sep1);

            // --- 3. LOOK AHEAD ---
            const lbl = document.createElement('span');
            lbl.innerText = "Look Ahead:";
            lbl.className = "font-semibold text-gray-600 mr-2";
            toolbar.appendChild(lbl);

            const dateInput = document.createElement('input');
            dateInput.type = 'date';
            dateInput.className = "border rounded px-2 py-1 text-sm";
            dateInput.value = State.lookAheadStart.toISOString().split('T')[0];
            dateInput.onchange = (e) => {
                State.lookAheadStart = new Date(e.target.value);
                State.showLookAhead = true;
                render();
            };
            toolbar.appendChild(dateInput);

            const weeksInput = document.createElement('input');
            weeksInput.type = 'number';
            weeksInput.className = "border rounded px-2 py-1 text-sm w-16 ml-2";
            weeksInput.value = State.lookAheadWeeks;
            weeksInput.min = 1;
            weeksInput.onchange = (e) => {
                State.lookAheadWeeks = parseInt(e.target.value);
                State.showLookAhead = true;
                render();
            };
            toolbar.appendChild(weeksInput);

            const wLabel = document.createElement('span');
            wLabel.innerText = "semanas";
            wLabel.className = "text-gray-600 ml-1 text-xs";
            toolbar.appendChild(wLabel);

            // --- 4. SEPARATOR ---
            const sep2 = createSeparator();
            toolbar.appendChild(sep2);

            // --- 5. EMPRESAS (COMPANIES) ---
            const btnCompanies = document.createElement('button');
            btnCompanies.className = "bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 px-3 py-1 rounded text-sm font-medium flex items-center shadow-sm";
            btnCompanies.innerHTML = '<i class="fas fa-building mr-2 text-blue-500"></i> Empresas';
            btnCompanies.onclick = openCompanyModal;
            toolbar.appendChild(btnCompanies);

            // --- 6. IMPORT (MPP) ---
            const btnImport = document.createElement('button');
            btnImport.className = "ml-2 bg-indigo-600 text-white hover:bg-indigo-700 px-3 py-1 rounded text-sm font-medium flex items-center shadow-sm";
            btnImport.innerHTML = '<i class="fas fa-file-import mr-2"></i> Importar .mpp';
            btnImport.onclick = () => document.getElementById('file-upload').click();
            toolbar.appendChild(btnImport);

            // Hidden File Input
            const fileInput = document.createElement('input');
            fileInput.id = 'file-upload';
            fileInput.type = 'file';
            fileInput.accept = '.mpp,.xml';
            fileInput.style.display = 'none';
            fileInput.onchange = handleFileUpload;
            toolbar.appendChild(fileInput);

            // --- 7. SEPARATOR ---
            toolbar.appendChild(createSeparator());

            // --- 8. FORMAT TOOLS ---
            injectFormatControls(toolbar);

            // --- 9. AUTO-SAVE STATUS ---
            const status = document.createElement('span');
            status.id = 'save-status';
            status.className = "ml-auto text-xs text-gray-400 font-medium italic";
            status.innerText = "Sincronizado";
            toolbar.appendChild(status);
        }

        function injectFormatControls(toolbar) {
            // Group for Format
            const group = document.createElement('div');
            group.className = "flex items-center space-x-1";

            // Bold
            const btnBold = createToolBtn('<i class="fas fa-bold"></i>', toggleBold);
            group.appendChild(btnBold);

            // Fill Color
            const inputFill = createColorInput('Fill', changeFill, '<i class="fas fa-fill-drip"></i>');
            group.appendChild(inputFill);

            // Text Color
            const inputText = createColorInput('Text', changeTextColor, '<i class="fas fa-font"></i>');
            group.appendChild(inputText);

            // Font Size
            const selectSize = document.createElement('select');
            selectSize.className = "border rounded text-xs py-1 px-1 w-12";
            [12, 13, 14, 16, 18].forEach(s => {
                const opt = document.createElement('option');
                opt.value = s;
                opt.text = s;
                selectSize.appendChild(opt);
            });
            selectSize.value = 13; // Default
            selectSize.onchange = (e) => changeFontSize(e.target.value);
            group.appendChild(selectSize);

            // Indentation
            const sepIndent = createSeparator();
            sepIndent.style.height = '16px'; // smaller sep inside group
            group.appendChild(sepIndent);

            const btnOutdent = createToolBtn('<i class="fas fa-outdent"></i>', () => HierarchyEngine.outdent());
            btnOutdent.title = "Outdent (Alt+Shift+Left)";
            group.appendChild(btnOutdent);

            const btnIndent = createToolBtn('<i class="fas fa-indent"></i>', () => HierarchyEngine.indent());
            btnIndent.title = "Indent (Alt+Shift+Right)";
            group.appendChild(btnIndent);

            toolbar.appendChild(group);
        }

        function createToolBtn(html, onClick) {
            const btn = document.createElement('button');
            btn.className = "text-gray-600 hover:bg-gray-100 p-1 rounded w-8 h-8 flex items-center justify-center";
            btn.innerHTML = html;
            btn.onclick = onClick;
            return btn;
        }

        function createColorInput(title, onChange, iconHtml) {
            const wrapper = document.createElement('div');
            wrapper.className = "relative inline-block w-8 h-8";

            const icon = document.createElement('div');
            icon.className = "absolute inset-0 flex items-center justify-center pointer-events-none text-gray-600";
            icon.innerHTML = iconHtml;

            const input = document.createElement('input');
            input.type = 'color';
            input.className = "opacity-0 w-full h-full cursor-pointer";
            input.oninput = (e) => onChange(e.target.value);

            wrapper.appendChild(input);
            wrapper.appendChild(icon);
            return wrapper;
        }

        // --- FORMATTING LOGIC ---
        function applyStyle(key, value) {
            // New Cell-Based Logic
            if (State.selectedCells.size === 0) return;

            State.selectedCells.forEach(cellKey => {
                const [taskId, colId] = cellKey.split(':');
                const task = State.tasks.find(t => t.id === taskId);
                if (task) {
                    if (!task.cellStyles) task.cellStyles = {};
                    if (!task.cellStyles[colId]) task.cellStyles[colId] = {};

                    task.cellStyles[colId][key] = value;
                    triggerAutoSave(task.id);
                }
            });
            render();
        }

        // --- GRID INTERACTION CONTROLLER ---
        const GridController = {
            handleMouseDown(e, task, colId) {
                if (e.button !== 0) return; // Only Left Click

                // If clicking fill handle (logic handled separately or check target class)
                if (e.target.classList.contains('fill-handle')) {
                    this.startFill(e);
                    return;
                }

                State.isDragging = true;
                State.isFilling = false;

                const cellKey = `${task.id}:${colId}`;

                if (e.ctrlKey) {
                    // Add/Remove
                    if (State.selectedCells.has(cellKey)) {
                        State.selectedCells.delete(cellKey);
                    } else {
                        State.selectedCells.add(cellKey);
                        State.activeCell = { taskId: task.id, colId };
                    }
                    State.anchorCell = { taskId: task.id, colId };
                } else if (e.shiftKey && State.activeCell) {
                    // Range Select
                    this.selectRange(State.activeCell, { taskId: task.id, colId });
                } else {
                    // Single Select
                    State.selectedCells.clear();
                    State.selectedCells.add(cellKey);
                    State.activeCell = { taskId: task.id, colId };
                    State.anchorCell = { taskId: task.id, colId };
                }

                render(); // Update Visuals
            },

            handleMouseEnter(e, task, colId) {
                if (State.isDragging && !State.isFilling) {
                    // Update Range Selection from Anchor to Current
                    this.selectRange(State.anchorCell, { taskId: task.id, colId });
                    render();
                }
                if (State.isFilling) {
                    // Update Target Range
                    const src = State.fillSourceRange;
                    if (!src) return;

                    // Determine Target Range based on Mouse Position vs Source
                    // We only support Vertical Fill for now
                    const targetTask = State.tasks.find(t => t.id === task.id);
                    if (!targetTask) return;

                    let startRow = src.startRow;
                    let endRow = src.endRow;

                    if (targetTask.orderIndex > src.endRow) {
                        // Dragging Down
                        endRow = targetTask.orderIndex;
                    } else if (targetTask.orderIndex < src.startRow) {
                        // Dragging Up (Optional? for now focus on Down)
                        startRow = targetTask.orderIndex;
                    }

                    State.fillTargetRange = { startRow, endRow };

                    // Visual Feedback: Select Target Cells temporarily?
                    // Or add specific class 'fill-target'?
                    // For now, let's just select them to show scope
                    // But "Selection" usually implies source. 
                    // Excel keeps source selected and adds border to target.
                    // We'll stick to simple selection expansion for now to save complexity.
                    this.selectRange(
                        { taskId: State.tasks[startRow].id, colId: State.activeCell.colId }, // Approx
                        { taskId: State.tasks[endRow].id, colId: State.activeCell.colId }
                    );
                    render();
                }
            },

            handleMouseUp() {
                if (State.isFilling) {
                    this.executeFill();
                }
                State.isDragging = false;
                State.isFilling = false;
                State.fillSourceRange = null;
                State.fillTargetRange = null;
            },

            selectRange(start, end) {
                State.selectedCells.clear();

                const startTask = State.tasks.find(t => t.id === start.taskId);
                const endTask = State.tasks.find(t => t.id === end.taskId);
                if (!startTask || !endTask) return;

                const startIdx = Math.min(startTask.orderIndex, endTask.orderIndex);
                const endIdx = Math.max(startTask.orderIndex, endTask.orderIndex);

                const cols = Config.columns.map(c => c.id);
                const c1 = cols.indexOf(start.colId);
                const c2 = cols.indexOf(end.colId);
                const startCol = Math.min(c1, c2);
                const endCol = Math.max(c1, c2);

                for (let r = startIdx; r <= endIdx; r++) {
                    const t = State.tasks[r];
                    if (!t) continue;
                    for (let c = startCol; c <= endCol; c++) {
                        State.selectedCells.add(`${t.id}:${cols[c]}`);
                    }
                }
            },

            startFill(e) {
                State.isFilling = true;
                State.isDragging = true;
                e.stopPropagation();

                // Calculate Source Range from Selection
                const indices = [];
                State.selectedCells.forEach(k => {
                    const [tid] = k.split(':');
                    const t = State.tasks.find(x => x.id === tid);
                    if (t) indices.push(t.orderIndex);
                });

                if (indices.length === 0) return;

                const minRow = Math.min(...indices);
                const maxRow = Math.max(...indices);

                State.fillSourceRange = {
                    startRow: minRow,
                    endRow: maxRow
                };
                // Initial Target is Source
                State.fillTargetRange = { ...State.fillSourceRange };
            },

            executeFill() {
                if (!State.fillSourceRange || !State.fillTargetRange) return;

                const src = State.fillSourceRange; // {startRow, endRow, ...}
                const tgt = State.fillTargetRange; // {startRow, endRow, ...}

                // For each selected column
                const sCells = Array.from(State.selectedCells);
                if (sCells.length === 0) return;

                // Group by Col
                const cols = new Set(sCells.map(k => k.split(':')[1]));

                cols.forEach(colId => {
                    // Get Source Values
                    const sourceValues = [];
                    for (let r = src.startRow; r <= src.endRow; r++) {
                        const tHash = State.tasks[r];
                        if (tHash) sourceValues.push(tHash[colId]);
                    }

                    // Detect Pattern
                    // Simple logic: if all numbers, check increment. If mixed or text, repeat sequence.
                    let isNumeric = sourceValues.every(v => !isNaN(parseFloat(v)) && isFinite(v));
                    let increment = 0;

                    if (isNumeric && sourceValues.length > 1) {
                        const n1 = parseFloat(sourceValues[0]);
                        const n2 = parseFloat(sourceValues[1]);
                        increment = n2 - n1;
                        // Verify consistency? Assume linear for now.
                    }

                    // Fill Target
                    let srcIdx = 0;
                    let lastVal = parseFloat(sourceValues[sourceValues.length - 1]);

                    for (let r = tgt.startRow; r <= tgt.endRow; r++) {
                        const targetTask = State.tasks[r];
                        if (!targetTask) continue;

                        let newVal;

                        if (isNumeric && sourceValues.length > 1) {
                            // Continue Pattern
                            lastVal += increment;
                            newVal = lastVal;
                            // Format back to string if needed?
                            // If duration, suffix 'días'? Duration logic handles raw numbers usually?
                            // 'duration' column logic: "5 días".
                            if (colId === 'duration') {
                                // Duration special handling?
                                // stored as '5 días'?
                                // Let's check getter... val = diffDays + ' días'.
                                // So sourceValues are strings "5 días".
                                // isNumeric will be false.
                            }
                        } else {
                            // Repeat Sequence
                            newVal = sourceValues[srcIdx % sourceValues.length];
                            srcIdx++;
                        }

                        // Apply
                        // Special Handling for Duration/Dates
                        if (colId === 'duration') {
                            // parse "5 días" -> 5
                            const days = parseInt(newVal) || 0;
                            if (targetTask.start && days > 0) {
                                const d = new Date(targetTask.start);
                                d.setDate(d.getDate() + days);
                                targetTask.end = d.toISOString().split('T')[0];
                            }
                        } else if (colId === 'start') {
                            // Date logic? For now strict copy.
                            targetTask.start = newVal;
                            // Update Duration?
                        } else {
                            targetTask[colId] = newVal;
                        }
                        triggerAutoSave(targetTask.id);
                    }
                });

                HierarchyEngine.recalculate(State.tasks);
                render();
            }
        };

        document.addEventListener('mouseup', () => GridController.handleMouseUp());

        // --- OLD FORMATTING LOGIC (MIGRATED ABOVE) ---
        // keeping helpers
        function toggleBold() {
            // check cell styles? 
            // Just toggle active cell's style
            if (State.selectedCells.size > 0) {
                // Check if first is bold
                const firstKey = Array.from(State.selectedCells)[0];
                const [tid, cid] = firstKey.split(':');
                const task = State.tasks.find(t => t.id === tid);
                const isBold = task.cellStyles && task.cellStyles[cid] && task.cellStyles[cid].fontWeight === 'bold';
                applyStyle('fontWeight', isBold ? 'normal' : 'bold');
            }
        }

        function changeFill(color) { applyStyle('backgroundColor', color); }
        function changeTextColor(color) { applyStyle('color', color); }
        function changeFontSize(size) { applyStyle('fontSize', size + 'px'); }

        // --- AUTO-SAVE LOGIC ---
        function triggerAutoSave(taskId) {
            State.dirtyTasks.add(taskId);

            const status = document.getElementById('save-status');
            if (status) {
                status.innerText = "Guardando...";
                status.classList.remove('text-green-500');
                status.classList.add('text-orange-400');
            }

            if (State.autoSaveTimer) clearTimeout(State.autoSaveTimer);
            State.autoSaveTimer = setTimeout(saveDirtyTasks, 1500); // 1.5s debounce
        }

        async function saveDirtyTasks() {
            if (State.dirtyTasks.size === 0) return;

            const tasksToSave = Array.from(State.dirtyTasks);
            State.dirtyTasks.clear(); // Optimistic clear

            console.log("AO Gantt: Auto-Saving", tasksToSave.length, "tasks");

            // We save sequentially or parallel? Parallel is fine.
            // Ideally backend supports bulk update, but we have /api/activities/{id}

            const promises = tasksToSave.map(async (id) => {
                const task = State.tasks.find(t => t.id === id);
                if (!task) return;

                // Construct Payload
                // Include Style, etc.
                const payload = {
                    name: task.name,
                    start: task.start,
                    end: task.end,
                    progress: task.progress, // mapped from pct
                    contractor: task.contractor,
                    style: JSON.stringify(task.style || {}), // Backend expects string? Check main.py
                    // main.py lines 817: try: act.style = data.style
                    // If backend model is string, we typically use JSON.dumps.
                    // If backend model is JSON column, better.
                    // Checking main.py: "style": getattr(act, 'style', None)
                    // It seems to be generic. Let's send generic JSON object if Pydantic supports it, or string.
                    // Main.py line 782: style: Optional[str] = None
                    // It expects STRING. So JSON.stringify is correct.
                    cell_styles: JSON.stringify(task.cellStyles || {}) // New: Cell-specific styles
                };

                try {
                    await fetch(`/api/activities/${id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                } catch (e) {
                    console.error("Failed to save", id, e);
                    State.dirtyTasks.add(id); // Re-add on failure
                }
            });

            await Promise.all(promises);

            const status = document.getElementById('save-status');
            if (status) {
                status.innerText = "Guardado";
                status.classList.remove('text-orange-400');
                status.classList.add('text-green-500');
            }
        }

        function createSeparator() {
            const sep = document.createElement('div');
            sep.style.width = '1px'; sep.style.height = '24px'; sep.style.background = '#e5e7eb'; sep.style.margin = '0 10px';
            return sep;
        }

        // --- IMPORT LOGIC ---
        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (!confirm(`¿Importar ${file.name}? Esto creará una nueva versión.`)) {
                e.target.value = ''; // Reset
                return;
            }

            const formData = new FormData();
            formData.append('file', file);

            const urlParts = window.location.pathname.split('/');
            const projectId = urlParts[urlParts.length - 1]; // Assume ID is last part

            const btn = e.target.previousElementSibling;
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Subiendo...';
            btn.disabled = true;

            try {
                const res = await fetch(`/api/projects/${projectId}/schedule`, {
                    method: 'POST',
                    body: formData
                });

                if (res.ok) {
                    alert('Importación exitosa. Recargando...');
                    window.location.reload();
                } else {
                    const err = await res.json();
                    alert('Error: ' + (err.detail || 'Error desconocido'));
                }
            } catch (err) {
                console.error(err);
                alert('Error de conexión');
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
                e.target.value = '';
            }
        }

        // --- COMPANIES LOGIC ---
        function openCompanyModal() {
            const contractors = new Set();
            State.tasks.forEach(t => {
                const c = t.contractor;
                if (c && c.trim() !== '' && c !== 'N/A') contractors.add(c.trim());
            });
            // Also add from companyColors keys (manual adds)
            Object.keys(State.companyColors).forEach(k => contractors.add(k));

            let overlay = document.getElementById('modal-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'modal-overlay';
                overlay.className = "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50";
                document.body.appendChild(overlay);
            }
            overlay.innerHTML = '';

            const modal = document.createElement('div');
            modal.className = "bg-white rounded-lg shadow-xl w-96 max-h-[80vh] flex flex-col";

            const header = document.createElement('div');
            header.className = "px-6 py-4 border-b flex justify-between items-center";
            header.innerHTML = '<h3 class="text-lg font-bold text-gray-800">Gestión de Empresas</h3><button onclick="closeModal()" class="text-gray-400 hover:text-gray-600"><i class="fas fa-times"></i></button>';
            modal.appendChild(header);

            // --- NEW: Add Company Section ---
            const addIdx = document.createElement('div');
            addIdx.className = "px-6 py-3 border-b bg-gray-50 flex space-x-2";
            const inputNew = document.createElement('input');
            inputNew.placeholder = "Nueva Empresa...";
            inputNew.className = "border rounded px-2 py-1 text-sm flex-1";

            const btnAdd = document.createElement('button');
            btnAdd.className = "bg-green-500 text-white px-3 py-1 rounded text-sm hover:bg-green-600";
            btnAdd.innerText = "+";
            btnAdd.onclick = () => {
                const val = inputNew.value.trim();
                if (val) {
                    if (!State.companyColors[val]) {
                        State.companyColors[val] = getRandomColor();
                        // Force re-render of modal
                        openCompanyModal();
                    }
                }
            };
            addIdx.appendChild(inputNew);
            addIdx.appendChild(btnAdd);
            modal.appendChild(addIdx);
            // --------------------------------

            const body = document.createElement('div');
            body.className = "p-6 overflow-y-auto flex-1";

            if (contractors.size === 0) {
                body.innerHTML = '<p class="text-gray-500 italic text-center">No hay empresas. Agrega una arriba.</p>';
            } else {
                contractors.forEach(c => {
                    const row = document.createElement('div');
                    row.className = "flex items-center justify-between mb-3";

                    const left = document.createElement('div');
                    left.className = "flex items-center";

                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.className = "w-6 h-6 rounded cursor-pointer border-0 mr-3 p-0";
                    // Get existing or assign default
                    if (!State.companyColors[c]) State.companyColors[c] = stringToColor(c);
                    colorInput.value = State.companyColors[c];
                    colorInput.onchange = (e) => {
                        State.companyColors[c] = e.target.value;
                        render(); // Re-render Gantt to update bars
                    };

                    const name = document.createElement('span');
                    name.className = "text-sm font-medium text-gray-700";
                    name.innerText = c;

                    // Assign Button (For Selection)
                    const btnAssign = document.createElement('button');
                    btnAssign.className = "ml-2 text-xs text-blue-500 hover:text-blue-700 underline";
                    btnAssign.innerText = "Asignar";
                    btnAssign.onclick = () => {
                        // Assign 'c' to all selected tasks
                        if (State.selectedIds.size === 0) {
                            alert("Selecciona tareas en el Gantt primero.");
                            return;
                        }
                        State.selectedIds.forEach(id => {
                            const t = State.tasks.find(tk => tk.id === id);
                            if (t) {
                                t.contractor = c;
                                triggerAutoSave(t.id);
                            }
                        });
                        render();
                        // Optional: Highlight success?
                    };

                    left.appendChild(colorInput);
                    left.appendChild(name);
                    left.appendChild(btnAssign);
                    row.appendChild(left);
                    body.appendChild(row);
                });
            }
            modal.appendChild(body);

            const footer = document.createElement('div');
            footer.className = "px-6 py-4 border-t bg-gray-50 flex justify-end";
            footer.innerHTML = '<button onclick="closeModal()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Cerrar</button>';
            modal.appendChild(footer);

            overlay.appendChild(modal);
            overlay.style.display = 'flex';
        }

        window.closeModal = function () {
            document.getElementById('modal-overlay').style.display = 'none';
        }

        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            let color = '#';
            for (let i = 0; i < 3; i++) {
                let value = (hash >> (i * 8)) & 0xFF;
                color += ('00' + value.toString(16)).substr(-2);
            }
            return color;
        }

        function scrollToToday() {
            const todayX = timeToX(new Date());
            const scroll = document.getElementById('master-scroll');
            const centerOffset = scroll.clientWidth / 2; // Center it
            // Adjust for sticky headers... assumes sticky headers are approx 600px
            const stickyW = getTotalStickyWidth();

            // We want Today to be at stickyW + (visible_gantt / 2)
            // scrollLeft controls the Gantt view offset.
            // Actually, sticky table means scrollLeft moves the whole table.

            scroll.scrollLeft = todayX - (scroll.clientWidth / 2) + stickyW;
        }

        // --- HIERARCHY ENGINE (Project-Like) ---
        const HierarchyEngine = {
            recalculate(tasks) {
                // 1. Reset
                tasks.forEach((t, i) => {
                    t.isSummary = false;
                    t.childrenIds = [];
                    t.parentId = null;
                    t.wbs = '';
                    t.orderIndex = i;
                });

                // 2. Build Tree
                const parentStack = [];

                tasks.forEach(task => {
                    const level = task.level;
                    parentStack[level] = task;

                    if (level > 0 && parentStack[level - 1]) {
                        const parent = parentStack[level - 1];
                        parent.childrenIds.push(task.id);
                        parent.isSummary = true;
                        task.parentId = parent.id;
                    }
                    // Clear deep stack
                    for (let l = level + 1; l < parentStack.length; l++) {
                        parentStack[l] = null;
                    }
                });
            },

            toggleCollapse(taskId) {
                const task = State.tasks.find(t => t.id === taskId);
                if (task && task.isSummary) {
                    task.collapsed = !task.collapsed;
                    render();
                }
            },

            // --- CORE SELECTION LOGIC ---
            getSelectionSegments() {
                // 1. Normalize Selection: Get all selected Tasks
                let selectedTasks = State.tasks.filter(t => State.selectedIds.has(t.id));
                if (selectedTasks.length === 0) return [];

                // 2. Expand Subtrees (If parent selected, include all children recursively)
                const fullSelectionSet = new Set();

                selectedTasks.forEach(task => {
                    fullSelectionSet.add(task);
                    // Include subtree
                    const subtree = this.getSubtree(task);
                    subtree.forEach(child => fullSelectionSet.add(child));
                });

                // Convert back to Array and Sort by Order
                const finalSelection = Array.from(fullSelectionSet).sort((a, b) => a.orderIndex - b.orderIndex);

                // 3. Group into Contiguous Segments
                const segments = [];
                let currentSegment = [];

                finalSelection.forEach((task, i) => {
                    if (currentSegment.length === 0) {
                        currentSegment.push(task);
                    } else {
                        const prev = currentSegment[currentSegment.length - 1];
                        if (task.orderIndex === prev.orderIndex + 1) {
                            currentSegment.push(task);
                        } else {
                            segments.push(currentSegment);
                            currentSegment = [task];
                        }
                    }
                });
                if (currentSegment.length > 0) segments.push(currentSegment);

                return segments;
            },

            indent() {
                const segments = this.getSelectionSegments();
                let changed = false;

                // Process segments from Bottom to Top to avoid validation issues? 
                // Actually top-down is fine for indent check.

                segments.forEach(segment => {
                    const topTask = segment[0];
                    if (topTask.orderIndex === 0) return; // Cannot indent first task

                    const prevTask = State.tasks[topTask.orderIndex - 1];
                    const newLevel = topTask.level + 1;

                    // Validation: Can process if prevTask exists.
                    // Project allows indent as long as prev task exists.
                    // It becomes child of prevTask. 

                    // Apply to ALL in segment
                    segment.forEach(t => {
                        t.level += 1;
                        triggerAutoSave(t.id);
                    });
                    changed = true;
                });

                if (changed) {
                    this.recalculate(State.tasks);
                    render();
                }
            },

            outdent() {
                const segments = this.getSelectionSegments();
                let changed = false;

                segments.forEach(segment => {
                    // Validation: Level > 0
                    const topTask = segment[0];
                    if (topTask.level <= 0) return; // Cannot outdent root

                    segment.forEach(t => {
                        if (t.level > 0) {
                            t.level -= 1;
                            triggerAutoSave(t.id);
                        }
                    });
                    changed = true;
                });

                if (changed) {
                    this.recalculate(State.tasks);
                    render();
                }
            },

            getSubtree(parent) {
                const results = [];
                const idx = parent.orderIndex;
                for (let i = idx + 1; i < State.tasks.length; i++) {
                    const t = State.tasks[i];
                    // Stop if we hit a task with level <= parent.level
                    if (t.level > parent.level) {
                        results.push(t);
                    } else {
                        break;
                    }
                }
                return results;
            }
        };

        // --- INTERACTION ---
        function handleGlobalKeys(e) {
            // Indent/Outdent
            if (e.altKey && e.shiftKey) {
                if (e.key === 'ArrowRight') {
                    HierarchyEngine.indent();
                    e.preventDefault();
                } else if (e.key === 'ArrowLeft') {
                    HierarchyEngine.outdent();
                    e.preventDefault();
                }
            }
        }

        function selectRow(task, mode) { // mode: 'single', 'multi', 'range'
            if (mode === 'single') {
                State.selectedIds.clear();
                State.selectedIds.add(task.id);
            } else if (mode === 'multi') {
                if (State.selectedIds.has(task.id)) State.selectedIds.delete(task.id);
                else State.selectedIds.add(task.id);
            } else {
                State.selectedIds.add(task.id);
            }
            State.lastSelectedId = task.id;
            render();
        }

        // --- RENDERERS ---
        function render() {
            renderHeader();
            renderBody();
            renderOverlays(); // Today Line & Look Ahead
        }

        function renderOverlays() {
            // New function to draw overlays on top of the bars
            // We'll reuse dependency-svg or creating a new "overlay-svg" on top?
            // Let's use 'dependency-svg' as it is already absolutely positioned.

            let svg = document.getElementById('dependency-svg');
            if (!svg) return; // Should exist by now

            // Clear previous overlays (but keep deps if we had them? We don't have deps yet)
            // For now, clear all because we redraw fresh
            svg.innerHTML = '';

            // 1. TODAY LINE
            const todayX = timeToX(new Date());
            if (todayX >= 0 && todayX <= State.totalWidth) {
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute('x1', todayX); line.setAttribute('y1', 0);
                line.setAttribute('x2', todayX); line.setAttribute('y2', svg.clientHeight);
                line.setAttribute('stroke', 'red');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('stroke-dasharray', '4');
                svg.appendChild(line);

                // Label "Today"
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute('x', todayX + 4); text.setAttribute('y', 12);
                text.textContent = "HOY";
                text.setAttribute('fill', 'red');
                text.setAttribute('font-size', '10');
                text.setAttribute('font-weight', 'bold');
                svg.appendChild(text);
            }

            // 2. LOOK AHEAD FRAME
            if (State.showLookAhead) {
                const startX = timeToX(State.lookAheadStart);
                const endDate = new Date(State.lookAheadStart);
                endDate.setDate(endDate.getDate() + (State.lookAheadWeeks * 7));
                const endX = timeToX(endDate);

                const w = endX - startX;
                if (w > 0) {
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', startX);
                    rect.setAttribute('y', 0);
                    rect.setAttribute('width', w);
                    rect.setAttribute('height', svg.clientHeight);
                    rect.setAttribute('fill', 'rgba(255, 0, 0, 0.05)'); // Very faint red
                    rect.setAttribute('stroke', 'red');
                    rect.setAttribute('stroke-width', '2');
                    svg.appendChild(rect);
                }
            }
        }

        function renderHeader() {
            const tr = document.getElementById('header-row');
            const timelineTh = document.getElementById('timeline-header-cell');

            // Clean logic (same as before)
            Array.from(tr.children).forEach(child => {
                if (child.id !== 'timeline-header-cell') tr.removeChild(child);
            });

            let leftOffset = 0;
            Config.columns.forEach(col => {
                const th = document.createElement('th');
                th.className = 'sticky-col';
                th.innerText = col.label;
                th.style.width = col.width + 'px';
                th.style.left = leftOffset + 'px';
                th.style.minWidth = col.width + 'px';
                const resizer = document.createElement('div');
                resizer.className = 'resizer';
                resizer.onmousedown = (e) => initResize(e, col);
                th.appendChild(resizer);
                tr.insertBefore(th, timelineTh);
                leftOffset += col.width;
            });

            State.totalWidth = calculateTotalWidth();
            timelineTh.style.width = State.totalWidth + 'px';
            timelineTh.style.minWidth = State.totalWidth + 'px';
            renderTimelineTicks(document.getElementById('timeline-svg'));
        }

        function renderTimelineTicks(svg) {
            svg.innerHTML = '';
            const zoom = State.zoom;
            let tickW = 50;

            // Tier 1 (Bottom) - The detailed tick
            // Tier 2 (Top) - The grouping tick (Month/Year)

            // CONFIG BASED ON ZOOM
            let bottomTierUnit = 'd'; // d=day, w=week, m=month
            let topTierUnit = 'm';    // m=month, y=year
            let bottomStep = 1;       // 1 day, 1 week

            if (zoom === 'DAY') { tickW = 40; bottomTierUnit = 'd'; topTierUnit = 'm'; }
            else if (zoom === 'WEEK') { tickW = 60; bottomTierUnit = 'w'; topTierUnit = 'm'; }
            else if (zoom === 'MONTH') { tickW = 100; bottomTierUnit = 'm'; topTierUnit = 'y'; }

            State.pxPerMin = tickW / (bottomTierUnit === 'd' ? 1440 : (bottomTierUnit === 'w' ? 10080 : 43200));

            // We need to re-render renderHeader to apply pxPerMin changes immediately if we set it here?
            // Better: use State.pxPerMin to derive tickW, not vice versa.
            // Let's invert: 
            // tickW = duration * pxPerMin

            // REFINED APPROACH: Use current pxPerMin to determine tick placement
            // Just draw ticks starting from startDate

            let curr = new Date(State.startDate);
            let x = 0;
            const H_TOP = 25;
            const H_BOT = 35; // Total 60

            // 1. Draw Bottom Tier & Grid Lines
            while (x < State.totalWidth) {
                // Determine next date and label
                let nextDate = new Date(curr);
                let label = '';

                if (zoom === 'DAY') {
                    nextDate.setDate(curr.getDate() + 1);
                    label = curr.getDate().toString();
                    // Weekday letter?
                    const days = ['D', 'L', 'M', 'X', 'J', 'V', 'S'];
                    label = days[curr.getDay()] + ' ' + label;
                } else if (zoom === 'WEEK') {
                    nextDate.setDate(curr.getDate() + 7);
                    label = `Sem ${getWeekNumber(curr)}`;
                } else { // MONTH
                    nextDate.setMonth(curr.getMonth() + 1);
                    label = curr.toLocaleDateString('es-ES', { month: 'short' });
                }

                const w = timeToX(nextDate) - timeToX(curr);

                // Rect
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute('x', x);
                rect.setAttribute('y', 30);
                rect.setAttribute('width', w);
                rect.setAttribute('height', 30);
                rect.setAttribute('fill', 'white');
                rect.setAttribute('stroke', '#e5e7eb');
                svg.appendChild(rect);

                // Text
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute('x', x + w / 2);
                text.setAttribute('y', 50);
                text.setAttribute('text-anchor', 'middle');
                text.textContent = label;
                text.setAttribute('font-size', '11');
                text.setAttribute('fill', '#6b7280');
                svg.appendChild(text);

                curr = nextDate;
                x = timeToX(curr);
            }

            // 2. Draw Top Tier (Months/Years)
            curr = new Date(State.startDate);
            x = 0;
            // Snap to first month/year boundary for smoother look? 
            // For now, just iterate safely.

            // We need to handle "Group By" rendering. 
            // Simpler approach: Iterate by Top Unit
            // But x is linear. 

            // Let's reset curr to start
            curr = new Date(State.startDate);
            // Snap curr to start of month if zoom is day/week
            if (zoom !== 'MONTH') curr.setDate(1);
            if (zoom === 'MONTH') curr.setMonth(0); // Year start

            // Adjust starting X (might be negative if startDate is mid-month)
            // We'll just draw valid months that overlap [0, totalWidth]

            let safety = 0;
            while (x < State.totalWidth && safety < 1000) {
                safety++;
                let nextTop = new Date(curr);
                let topLabel = '';

                if (zoom === 'MONTH') {
                    nextTop.setFullYear(curr.getFullYear() + 1);
                    topLabel = curr.getFullYear();
                } else { // DAY/WEEK -> Group by Month
                    nextTop.setMonth(curr.getMonth() + 1);
                    topLabel = curr.toLocaleDateString('es-ES', { month: 'long', year: 'numeric' });
                }

                const xStart = Math.max(0, timeToX(curr));
                const xEnd = timeToX(nextTop);

                if (xEnd > 0) {
                    const w = xEnd - xStart;
                    const topRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    topRect.setAttribute('x', xStart); topRect.setAttribute('y', 0);
                    topRect.setAttribute('width', w); topRect.setAttribute('height', 30);
                    topRect.setAttribute('fill', '#f9fafb'); topRect.setAttribute('stroke', '#e5e7eb');
                    svg.appendChild(topRect);

                    const topText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    topText.setAttribute('x', xStart + 10); topText.setAttribute('y', 20);
                    topText.textContent = topLabel;
                    topText.setAttribute('font-size', '12'); topText.setAttribute('font-weight', 'bold');
                    topText.setAttribute('fill', '#374151');
                    svg.appendChild(topText);
                }

                curr = nextTop;
                if (timeToX(curr) > State.totalWidth) break;
            }
        }

        function getWeekNumber(d) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return weekNo;
        }

        function renderBody() {
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';

            // Dependency Overlay Logic
            let depSvg = document.getElementById('dependency-svg');
            const masterScroll = document.getElementById('master-scroll');
            if (!depSvg) {
                depSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                depSvg.id = 'dependency-svg';
                depSvg.style.position = 'absolute';
                depSvg.style.top = '60px';
                depSvg.style.pointerEvents = 'none';
                depSvg.style.zIndex = '10'; // Ensure overlay is on top of grid but below some tools?
                masterScroll.appendChild(depSvg);
            }
            depSvg.style.left = getTotalStickyWidth() + 'px';
            depSvg.style.width = State.totalWidth + 'px';
            depSvg.style.height = Math.max(State.tasks.length * 32, 500) + 'px';

            // Look Ahead Range
            let laStart = null, laEnd = null;
            if (State.showLookAhead) {
                laStart = State.lookAheadStart;
                laEnd = new Date(laStart);
                laEnd.setDate(laEnd.getDate() + (State.lookAheadWeeks * 7));
            }

            let hiddenLevel = -1;

            State.tasks.forEach(task => {
                if (hiddenLevel > -1 && task.level > hiddenLevel) return;
                if (hiddenLevel > -1 && task.level <= hiddenLevel) hiddenLevel = -1;
                if (task.isSummary && task.collapsed && hiddenLevel === -1) hiddenLevel = task.level;

                // LOOK AHEAD HIGHLIGHT LOGIC
                // Check intersection
                let isHighlighted = false;
                if (laStart && task.start && task.end) {
                    const tStart = new Date(task.start);
                    const tEnd = new Date(task.end);
                    if (tStart < laEnd && tEnd > laStart) {
                        isHighlighted = true;
                    }
                }

                const tr = document.createElement('tr');
                // Row selection deprecated in favor of cell selection?
                // Or keep row selection visual if "Selecting Row Header"? 
                // For now transparency

                let leftOffset = 0;
                Config.columns.forEach(col => {
                    const td = document.createElement('td');
                    td.className = 'sticky-col select-none'; // select-none to prevent text selection while dragging
                    td.style.left = leftOffset + 'px';
                    td.style.width = col.width + 'px';
                    td.style.minWidth = col.width + 'px';
                    // td.style.position = 'absolute'; // Sticky needs absolute inside sticky container? 
                    // No, implementation earlier used sticky-col class which has position:sticky.
                    // But if I use absolute here, it breaks sticky.
                    // sticky-col class handles left/position.

                    const cellKey = `${task.id}:${col.id}`;
                    const isSelected = State.selectedCells.has(cellKey);

                    if (isSelected) {
                        td.classList.add('selected-cell');
                        // Add Borders? 
                        // Logic for borders requires checking neighbors (efficiently).
                        // Or just simple border for now. CSS handles simple border.
                    }

                    // Attach Events
                    td.onmousedown = (e) => GridController.handleMouseDown(e, task, col.id);
                    td.onmouseenter = (e) => GridController.handleMouseEnter(e, task, col.id);

                    if (col.id === 'name') {
                        td.style.paddingLeft = (task.level * 20 + 8) + 'px';
                        td.style.display = 'flex'; td.style.alignItems = 'center';
                        if (task.isSummary) {
                            const icon = document.createElement('i');
                            icon.className = `fas fa-caret-${task.collapsed ? 'right' : 'down'} mr-2 cursor-pointer`;
                            icon.onclick = (e) => { e.stopPropagation(); HierarchyEngine.toggleCollapse(task.id); };
                            td.appendChild(icon);
                        }
                    }

                    const span = document.createElement('span');
                    let val = task[col.id];
                    if (col.id === 'start' || col.id === 'end') val = val ? val.toString().split('T')[0] : '';
                    if (col.id === 'progress') {
                        let n = parseFloat(val);
                        if (isNaN(n)) n = 0;
                        val = Math.round(n) + '%';
                    }
                    if (col.id === 'duration') {
                        if (task.start && task.end) {
                            const d1 = new Date(task.start);
                            const d2 = new Date(task.end);
                            const diffTime = Math.abs(d2 - d1);
                            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                            val = diffDays + ' días';
                        } else {
                            val = '';
                        }
                    }

                    span.innerText = val || '';
                    span.style.width = "100%";

                    // APPLY CELL STYLES
                    if (task.cellStyles && task.cellStyles[col.id]) {
                        const s = task.cellStyles[col.id];
                        if (s.fontWeight) span.style.fontWeight = s.fontWeight;
                        if (s.color) span.style.color = s.color;
                        if (s.backgroundColor) td.style.backgroundColor = s.backgroundColor; // BG on TD
                        if (s.fontSize) span.style.fontSize = s.fontSize;
                    }

                    if (col.editable) {
                        span.contentEditable = true;

                        // Prevent row selection when clicking to edit
                        span.onmousedown = (e) => { e.stopPropagation(); }; // Allow text selection

                        span.onblur = (e) => {
                            let newVal = e.target.innerText;
                            // ... (Save Logic) ...
                            // Copied from previous logic, condensed for brevity?
                            // No, must replicate logic or use shared handler.
                            updateTaskValue(task, col.id, newVal);
                        };
                    }
                    td.appendChild(span);

                    // FILL HANDLE (If Active Cell)
                    if (State.activeCell && State.activeCell.taskId === task.id && State.activeCell.colId === col.id) {
                        const handle = document.createElement('div');
                        handle.className = 'fill-handle';
                        td.appendChild(handle);
                    }

                    tr.appendChild(td);
                    leftOffset += col.width;
                });

                // --- Helper for updating task ---
                function updateTaskValue(task, colId, newVal) {
                    if (colId === 'duration') {
                        const days = parseInt(newVal) || 0;
                        if (task.start && days > 0) {
                            const d = new Date(task.start);
                            d.setDate(d.getDate() + days);
                            task.end = d.toISOString().split('T')[0];
                            triggerAutoSave(task.id);
                            HierarchyEngine.recalculate(State.tasks);
                            render();
                        }
                    } else if (colId === 'start') {
                        task.start = newVal;
                        triggerAutoSave(task.id);
                        HierarchyEngine.recalculate(State.tasks);
                        render();
                    } else if (colId === 'end') {
                        task.end = newVal;
                        triggerAutoSave(task.id);
                        HierarchyEngine.recalculate(State.tasks);
                        render();
                    } else {
                        task[colId] = newVal;
                        triggerAutoSave(task.id);
                    }
                }

                const ganttTd = document.createElement('td');
                ganttTd.className = 'gantt-cell';
                const barSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                barSvg.style.width = State.totalWidth + 'px';
                barSvg.style.height = '100%';
                barSvg.style.display = 'block';

                if (task.start && task.end) {
                    const x = timeToX(task.start);
                    const w = timeToX(task.end) - x;

                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

                    let barH = 20;
                    let barY = 6;
                    let barColor = '#3b82f6';
                    let barRadius = 3;

                    if (task.isSummary) {
                        barH = 12; barY = 6; barColor = '#000'; barRadius = 0;
                        // Summary Bar (Black Bracket)
                        const rect = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        // Draw bracket shape
                        // M x,y+h L x,y L x+w,y L x+w,y+h
                        const d = `M ${x},${barY + barH} L ${x},${barY} L ${x + w},${barY} L ${x + w},${barY + barH}`;
                        rect.setAttribute('d', d);
                        rect.setAttribute('fill', 'none');
                        rect.setAttribute('stroke', '#000');
                        rect.setAttribute('stroke-width', '2');
                        g.appendChild(rect);
                    } else {
                        // Standard Task Bar
                        // 1. Background (Light Blue)
                        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        bgRect.setAttribute('x', x); bgRect.setAttribute('y', barY);
                        bgRect.setAttribute('width', Math.max(w, 5)); bgRect.setAttribute('height', barH);

                        // COLOR LOGIC: Check Company Color -> Default Blue
                        const companyColor = (task.contractor && State.companyColors[task.contractor]) ? State.companyColors[task.contractor] : '#dbeafe';
                        // If company color is set, use it for background? Or Progress?
                        // Usually Gantt background is pale, progress is dark.
                        // Let's make Background = Pale version of Company Color? 
                        // Or just use Company Color for Progress and standard pale blue for background?
                        // User Request: "sus colores". Implicitly distinctive.

                        // Revised: 
                        // Background = light gray/blue standard (or very light version of company color if we want to be fancy)
                        // Progress = Company Color.

                        // Let's stick to requested "Agrega los botones... por ejemplo el de empresas y sus colores".
                        // If I change the progress color, it overrides the 'dark blue' for progress.
                        // Let's update the PROGRESS bar color to be the company color.
                        // And Background to be a default pale, or matching pale.

                        // Simple: Background #dbeafe (default). 
                        // Progress uses Company Color if exists, else #3b82f6.

                        bgRect.setAttribute('fill', isHighlighted ? '#fecaca' : '#dbeafe'); // Red/Blue

                        bgRect.setAttribute('rx', barRadius);
                        g.appendChild(bgRect);

                        // 2. Progress (Dark Blue)
                        const pct = parseFloat(task.progress || 0) / 100;
                        if (pct > 0 && !isNaN(pct)) {
                            const progRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            progRect.setAttribute('x', x); progRect.setAttribute('y', barY);
                            const companyFill = (task.contractor && State.companyColors[task.contractor]) ? State.companyColors[task.contractor] : '#3b82f6';

                            progRect.setAttribute('width', Math.max(w * pct, 0));
                            progRect.setAttribute('height', barH);
                            progRect.setAttribute('fill', isHighlighted ? '#dc2626' : companyFill); progRect.setAttribute('rx', barRadius);
                            g.appendChild(progRect);
                        }
                    }
                    barSvg.appendChild(g);
                }
                ganttTd.appendChild(barSvg);
                tr.appendChild(ganttTd);
                tbody.appendChild(tr);
            });
        }


        function getTotalStickyWidth() { return Config.columns.reduce((sum, col) => sum + col.width, 0); }

        function initTimeEngine() {
            if (State.tasks.length > 0) {
                // If tasks exist, maybe center on them?
                // But USER REQUEST: "siempre al iniciar el proyecto que el proyecto se ubique en el dia de hoy"
                // So startDate should perhaps be Today - Offset?

                let min = new Date(); // Start around today
                min.setDate(min.getDate() - 30); // 1 month buffer
                State.startDate = min;

                // However, we should also respect task bounds if they are way in the past?
                // Let's stick to the "Scroll to Today" logic instead of changing StartDate too much
                // But we need startDate to be before Today for Today to be visible.
            } else { State.startDate = new Date(); }
        }
        function calculateTotalWidth() { return 3000; }
        function timeToX(dateStr) {
            const d = new Date(dateStr);
            const diffMins = (d - State.startDate) / 60000;
            return diffMins * State.pxPerMin;
        }
        function initResize(e, col) {
            e.preventDefault();
            const startX = e.clientX;
            const startW = col.width;

            const onMove = (mv) => {
                col.width = Math.max(30, startW + (mv.clientX - startX));
                render();
            };

            const onUp = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            };

            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }

        window.AO = {
            Gantt: {
                zoomIn: () => { State.pxPerMin *= 1.2; render(); },
                zoomOut: () => { State.pxPerMin *= 0.8; render(); }
            }
        };

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }
    </script>
</body>

</html>