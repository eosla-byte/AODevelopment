<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ project.name }} - Scheduling Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --row-height: 32px;
            --header-height: 60px;
            --col-id-width: 40px;
            --col-name-width: 300px;
            --col-start-width: 100px;
            --col-end-width: 100px;
            --col-dur-width: 80px;
            --col-pct-width: 60px;

            --sticky-left-total: calc(40px + 300px + 100px + 100px + 80px + 60px);
            /* Adjust based on visible cols */

            --grid-border: 1px solid #e5e7eb;
            --bg-header: #f9fafb;
        }

        * {
            box-sizing: border-box;
        }

        body,
        html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', sans-serif;
            font-size: 13px;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #toolbar {
            height: 48px;
            flex-shrink: 0;
            border-bottom: var(--grid-border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 8px;
            z-index: 100;
            background: white;
        }

        /* --- THE MASTER SCROLL CONTAINER --- */
        #master-scroll {
            flex: 1;
            overflow: auto;
            /* The ONLY scrollbar */
            position: relative;
            background: white;
        }

        /* --- THE GIANT GRID --- */
        #main-table {
            border-collapse: separate;
            /* Required for sticky */
            border-spacing: 0;
            table-layout: fixed;
            width: max-content;
            /* Allows horizontal growth */
        }

        /* Headers */
        thead th {
            position: sticky;
            top: 0;
            z-index: 40;
            height: var(--header-height);
            background: var(--bg-header);
            border-bottom: var(--grid-border);
            border-right: var(--grid-border);
            vertical-align: middle;
            /* Center vertically specifically for Timeline */
        }

        /* Fixed Columns (Left) */
        .sticky-col {
            position: sticky;
            z-index: 30;
            background: white;
            /* Cover Gantt bars sliding under */
            left: 0;
            /* JS updates this for subsequent cols */
        }

        /* Corner Headers (Top-Left) - The "Pivot" */
        thead th.sticky-col {
            z-index: 50;
            /* Above everything */
            background: #f3f4f6;
        }

        /* CONTEXT MENU */
        #context-menu {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
            min-width: 150px;
            border-radius: 4px;
        }

        #context-menu .item {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            color: #333;
        }

        #context-menu .item:hover {
            background-color: #f0f0f0;
        }

        #context-menu .separator {
            border-top: 1px solid #eee;
            margin: 4px 0;
        }

        /* COMMENTS MODAL */
        .comment-bubble {
            background: #f3f4f6;
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 13px;
            position: relative;
        }

        .comment-bubble.me {
            background: #dbeafe;
            /* Blue tint */
            margin-left: 20px;
        }

        .comment-header {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
        }

        .comment-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            margin-right: 8px;
            object-fit: cover;
        }

        .attachment-preview {
            display: inline-block;
            margin-top: 5px;
            border: 1px solid #ddd;
            padding: 4px;
            border-radius: 4px;
            cursor: pointer;
        }

        /* SCROLL BARS */
        td {
            height: var(--row-height);
            border-bottom: var(--grid-border);
            border-right: var(--grid-border);
            padding: 0 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Timeline Header Cell */
        #timeline-header-cell {
            padding: 0;
            margin: 0;
            background: white;
        }

        /* Resizers */
        .resizer {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            cursor: col-resize;
            z-index: 60;
        }

        .resizer:hover {
            background: #3b82f6;
        }

        /* Row Highlights */
        tr:hover td {
            background-color: #f3f9ff;
        }

        /* Gantt Cell */
        .gantt-cell {
            padding: 0;
            margin: 0;
            vertical-align: top;
            position: relative;
        }

        /* Grid Selection Styles */
        .selected-cell {
            background-color: rgba(59, 130, 246, 0.1) !important;
            border: 1px solid #3b82f6 !important;
        }

        .fill-handle {
            width: 8px;
            height: 8px;
            background-color: #3b82f6;
            position: absolute;
            bottom: -4px;
            right: -4px;
            cursor: crosshair;
            z-index: 10;
        }

        .selection-border-top {
            border-top: 2px solid #3b82f6 !important;
        }

        .selection-border-bottom {
            border-bottom: 2px solid #3b82f6 !important;
        }

        .selection-border-left {
            border-left: 2px solid #3b82f6 !important;
        }

        .selection-border-right {
            border-right: 2px solid #3b82f6 !important;
        }

        /* Task Details Card */
        .task-card-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .task-card {
            background: white;
            width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            font-family: 'Inter', sans-serif;
        }

        .card-header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .card-body {
            padding: 20px;
        }

        .card-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 16px;
        }

        .card-label {
            font-size: 0.75rem;
            color: #6b7280;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .card-value {
            font-size: 0.95rem;
            font-weight: 500;
            color: #111827;
        }

        .metric-chart {
            width: 100%;
            height: 100px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            position: relative;
            margin-top: 10px;
        }
    </style>
</head>

<body>
    <div id="app">
        <!-- Context Menu -->
        <div id="context-menu" class="hidden">
            <div class="item" onclick="insertTask('above')"><i class="fas fa-arrow-up mr-2 text-gray-400"></i> Insertar
                Tarea Arriba</div>
            <div class="item" onclick="insertTask('below')"><i class="fas fa-arrow-down mr-2 text-gray-400"></i>
                Insertar Tarea Abajo</div>
            <div class="separator"></div>
            <div class="item" onclick="triggerAddExtraTime()"><i class="fas fa-clock mr-2 text-red-500"></i> Agregar
                Tiempo
                Extra</div>
            <!-- Future: Delete, Indent, etc. -->
        </div>

        <!-- SVG DEFS for Patterns -->
        <svg width="0" height="0" style="position:absolute">
            <defs>
                <pattern id="hatchPattern" patternUnits="userSpaceOnUse" width="4" height="4">
                    <path d="M-1,1 l2,-2
                         M0,4 l4,-4
                         M3,5 l2,-2" style="stroke:red; stroke-width:1" />
                </pattern>
            </defs>
        </svg>


        <!-- TOOLBAR -->
        <div id="toolbar">
            <h1 class="font-bold mr-4">{{ project.name }}</h1>
            <span class="text-xs text-green-500 font-bold">DEPLOY_FIX_FINAL_V2</span>

            <!-- Zoom Controls -->
            <button class="bg-gray-100 hover:bg-gray-200 p-1.5 rounded" onclick="AO.Gantt.zoomOut()">
                <i class="fas fa-minus"></i>
            </button>
            <span id="zoom-label" class="w-16 text-center font-mono text-xs">WEEK</span>
            <button class="bg-gray-100 hover:bg-gray-200 p-1.5 rounded" onclick="AO.Gantt.zoomIn()">
                <i class="fas fa-plus"></i>
            </button>
            <div class="border-l h-6 mx-2 border-gray-300"></div>

            <!-- ADD TASK BUTTON -->
            <button
                class="bg-red-600 hover:bg-red-700 text-white p-1.5 rounded flex items-center justify-center w-8 h-8 shadow-sm transition"
                title="Agregar Tarea" onclick="addTask()">
                <i class="fas fa-plus font-bold"></i>
            </button>
            <div class="border-l h-6 mx-2 border-gray-300"></div>

            <!-- Actions -->
            <div class="flex items-center space-x-2 ml-auto">
                <div class="flex space-x-2">
                    <a href="/api/projects/{{ project.id }}/export" target="_blank"
                        class="bg-indigo-600 text-white px-3 py-1 rounded shadow text-sm flex items-center hover:bg-indigo-700">
                        <i class="fas fa-file-export mr-2"></i> Exportar
                    </a>
                    <button onclick="document.getElementById('file-upload').click()"
                        class="bg-blue-600 text-white px-3 py-1 rounded shadow text-sm flex items-center hover:bg-blue-700">
                        <i class="fas fa-file-import mr-2"></i> Importar .mpp
                    </button>
                    <input type="file" id="file-upload" class="hidden" accept=".mpp,.xml"
                        onchange="handleFileUploadV2(event)">
                    <button onclick="saveAll()" id="btn-save-all"
                        class="bg-green-600 text-white px-3 py-1 rounded shadow text-sm flex items-center hover:bg-green-700">
                        <i class="fas fa-save mr-2"></i> Guardar Todo
                    </button>
                </div>
                <div id="save-status" class="text-xs text-gray-500 font-medium w-24 text-right">Sincronizado</div>
                <button onclick="openTaskBoard()"
                    class="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm flex items-center shadow-sm transition font-bold ml-2">
                    <i class="fas fa-columns mr-2"></i> TASK
                </button>
            </div>
        </div>

        <!-- MASTER SCROLL -->
        <div id="master-scroll">
            <table id="main-table">
                <thead>
                    <tr id="header-row">
                        <!-- LEFT COLUMNS (JS Generated) -->
                        <!-- RIGHT TIMELINE (Single Giant TH) -->
                        <th id="timeline-header-cell">
                            <svg id="timeline-svg" height="60" width="100%"></svg>
                        </th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    <!-- ROWS (JS Generated) -->
                </tbody>
            </table>

            <!-- GANTT OVERLAY (Absolute, for Bars) -->
            <!-- We render bars inside the last TD of each row or a separate overlay? 
                 Better: Render bars in an SVG inside the last TD of *each row*? No, too many SVGs.
                 Better: One Giant SVG overlaying the right side? 
                 Solution: The last column is the "Gantt Column". 
            -->
        </div>
    </div>

    <script type="module">
        // --- CONFIG ---
        const Config = {
            columns: [
                { id: 'contractor', label: 'Empresa', width: 150, align: 'left', editable: true }, // Replaced ID (WBS)
                { id: 'name', label: 'Tarea', width: 300, align: 'left', editable: true },
                { id: 'duration', label: 'Duración', width: 80, align: 'center', editable: true }, // New Duration
                { id: 'start', label: 'Inicio', width: 100, align: 'center', editable: true },
                { id: 'end', label: 'Fin', width: 100, align: 'center', editable: true },
                { id: 'progress', label: '%', width: 60, align: 'center', editable: true }
            ],
            rowHeight: 32,
            headerHeight: 60
        };

        const State = {
            tasks: [], // includes level, collapsed, isSummary
            zoom: 'WEEK',
            pxPerMin: 0.01,
            startDate: new Date(),
            totalWidth: 2000,
            selectedIds: new Set(),
            lastSelectedId: null,
            // Look Ahead State
            lookAheadStart: new Date(),
            lookAheadWeeks: 3,
            showLookAhead: false,
            companyColors: {},
            hiddenContractors: new Set(),

            projectSettings: {},
            // Formatting & AutoSave
            autoSaveTimer: null,
            dirtyTasks: new Set(),
            // Grid Interaction
            selectedCells: new Set(), // "taskId:colId"
            activeCell: null, // {taskId, colId}
            anchorCell: null, // {taskId, colId}
            isDragging: false,
            isFilling: false,
            fillSourceRange: null, // {startRow, endRow, tasks: []}
            // Navigation & Editing
            interactionMode: 'NAVIGATION', // 'NAVIGATION', 'SELECTING', 'EDITING'
            editingValue: '',
            contextTask: null // Store task for context menu action
        };





        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("AO Gantt: Starting...");
            try {
                const serverTasks = {{ tasks | tojson | safe
            }};
        console.log("AO Gantt: Tasks loaded:", serverTasks ? serverTasks.length : 0);
        if (serverTasks && serverTasks.length > 0) {
            const debugTask = serverTasks.find(t => t.server_id == '4615' || t.id == '4615' || t.id.includes('4615'));
            console.log("DEBUG Persistence Check - First Task:", serverTasks[0]);
            if (debugTask) {
                console.log("DEBUG Persistence Check - Target Task (4615):", debugTask);
                console.log("DEBUG 4615 extension_days:", debugTask.extension_days);
                console.log("DEBUG 4615 cell_styles:", debugTask.cell_styles);
                alert(`DEBUG: Task 4615 Loaded.\nExt Days: ${debugTask.extension_days}\nStyles: ${JSON.stringify(debugTask.cell_styles)}`);
            }
        }

        if (!serverTasks || !Array.isArray(serverTasks)) {
            console.error("AO Gantt: Invalid tasks data", serverTasks);
            return;
        }

        // Post-process server tasks
        // Defensive check: use explicitly passed safe settings
        const projectSettings = {{ project_settings_json | tojson | safe }} || {};
        State.projectSettings = projectSettings;
        if (projectSettings.companyColors) {
            State.companyColors = projectSettings.companyColors;
        }

        State.tasks = serverTasks.map((t, i) => {
            const parsedStyle = (typeof t.style === 'string' ? JSON.parse(t.style) : (t.style || {}));
            return {
                ...t,
                style: parsedStyle, // Keep as object
                cellStyles: (typeof t.cell_styles === 'string' ? JSON.parse(t.cell_styles) : (t.cell_styles || {})),
                extension_days: t.extension_days || 0,
                level: parsedStyle.level !== undefined ? parsedStyle.level : (t.level || 0),
                collapsed: parsedStyle.collapsed !== undefined ? parsedStyle.collapsed : false,
                isSummary: false, // Calculated later
                childrenIds: [],
                parentId: null,
                orderIndex: i, // Prefer t.display_order if available?
                comments: (typeof t.comments === 'string' ? JSON.parse(t.comments) : (t.comments || []))
            }
        });

        // Init Company Colors
        State.tasks.forEach(t => {
            if (t.contractor && !State.companyColors[t.contractor]) {
                State.companyColors[t.contractor] = '#' + Math.floor(Math.random() * 16777215).toString(16);
                saveProjectSettings(); // Save new discovered colors
            }
        });

        // Init Look Ahead defaults (Today)
        const today = new Date();
        State.lookAheadStart = new Date(today);

        // Toolbar Injection for Look Ahead
        injectToolbarControls();

        initTimeEngine();
        HierarchyEngine.recalculate(State.tasks);
        render();

        // Auto-Scroll to Today
        setTimeout(scrollToToday, 100);

        // Global Keys
        document.addEventListener('keydown', handleGlobalKeys);

        // Context Menu Listeners
        document.addEventListener('click', hideContextMenu);
        // Context menu handled globally now
        // document.getElementById('main-table').addEventListener('contextmenu', handleContextMenu);

        console.log("AO Gantt: Render complete");
            } catch (e) {
            console.error("AO Gantt: Crash during init", e);
            alert("Error loading Gantt: " + e.message);
        }
        });

        // --- CONTROLS INJECTION ---
        function injectToolbarControls() {
            const toolbar = document.getElementById('toolbar');

            // --- EXISTING 1: ZOOM ---
            // (Assumed existing zoom buttons are there or we leave them alone if hardcoded)

            // --- 2. SEPARATOR ---
            const sep1 = createSeparator();
            toolbar.appendChild(sep1);

            // --- 3. LOOK AHEAD ---
            const lbl = document.createElement('span');
            lbl.innerText = "Look Ahead:";
            lbl.className = "font-semibold text-gray-600 mr-2 cursor-pointer select-none border-b border-transparent hover:border-gray-400";
            lbl.title = "Click to Toggle visibility";
            lbl.onclick = () => {
                State.showLookAhead = !State.showLookAhead;
                render();
            };
            toolbar.appendChild(lbl);

            const dateInput = document.createElement('input');
            dateInput.type = 'date';
            dateInput.className = "border rounded px-2 py-1 text-sm";
            dateInput.value = State.lookAheadStart.toISOString().split('T')[0];
            dateInput.onchange = (e) => {
                State.lookAheadStart = new Date(e.target.value);
                // State.showLookAhead = true; // Don't auto-force if user toggled off? Or yes? User asked for toggle.
                render();
            };
            toolbar.appendChild(dateInput);

            const weeksInput = document.createElement('input');
            weeksInput.type = 'number';
            weeksInput.className = "border rounded px-2 py-1 text-sm w-16 ml-2";
            weeksInput.value = State.lookAheadWeeks;
            weeksInput.min = 1;
            weeksInput.onchange = (e) => {
                State.lookAheadWeeks = parseInt(e.target.value);
                State.showLookAhead = true;
                render();
            };
            toolbar.appendChild(weeksInput);

            const wLabel = document.createElement('span');
            wLabel.innerText = "semanas";
            wLabel.className = "text-gray-600 ml-1 text-xs";
            toolbar.appendChild(wLabel);

            // --- 4. SEPARATOR ---
            const sep2 = createSeparator();
            toolbar.appendChild(sep2);

            // --- 5. EMPRESAS (COMPANIES) ---
            const btnCompanies = document.createElement('button');
            btnCompanies.className = "bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 px-3 py-1 rounded text-sm font-medium flex items-center shadow-sm";
            btnCompanies.innerHTML = '<i class="fas fa-building mr-2 text-blue-500"></i> Empresas';
            btnCompanies.onclick = openCompanyModal;
            toolbar.appendChild(btnCompanies);

            // --- 7. SEPARATOR ---
            toolbar.appendChild(createSeparator());

            // --- 8. FORMAT TOOLS ---
            injectFormatControls(toolbar);

            // --- 9. AUTO-SAVE STATUS ---
            const status = document.createElement('span');
            status.id = 'save-status';
            status.className = "ml-auto text-xs text-gray-400 font-medium italic";
            status.innerText = "Sincronizado";
            toolbar.appendChild(status);
        }

        function injectFormatControls(toolbar) {
            // Group for Format
            const group = document.createElement('div');
            group.className = "flex items-center space-x-1";

            // Bold
            const btnBold = createToolBtn('<i class="fas fa-bold"></i>', toggleBold);
            group.appendChild(btnBold);

            // Fill Color
            const inputFill = createColorInput('Fill', changeFill, '<i class="fas fa-fill-drip"></i>');
            group.appendChild(inputFill);

            // Text Color
            const inputText = createColorInput('Text', changeTextColor, '<i class="fas fa-font"></i>');
            group.appendChild(inputText);

            // Font Size
            const selectSize = document.createElement('select');
            selectSize.className = "border rounded text-xs py-1 px-1 w-12";
            [12, 13, 14, 16, 18].forEach(s => {
                const opt = document.createElement('option');
                opt.value = s;
                opt.text = s;
                selectSize.appendChild(opt);
            });
            selectSize.value = 13; // Default
            selectSize.onchange = (e) => changeFontSize(e.target.value);
            group.appendChild(selectSize);

            // Indentation
            const sepIndent = createSeparator();
            sepIndent.style.height = '16px'; // smaller sep inside group
            group.appendChild(sepIndent);

            const btnOutdent = createToolBtn('<i class="fas fa-outdent"></i>', () => HierarchyEngine.outdent());
            btnOutdent.title = "Outdent (Alt+Shift+Left)";
            group.appendChild(btnOutdent);

            const btnIndent = createToolBtn('<i class="fas fa-indent"></i>', () => HierarchyEngine.indent());
            btnIndent.title = "Indent (Alt+Shift+Right)";
            group.appendChild(btnIndent);

            toolbar.appendChild(group);
        }

        function createToolBtn(html, onClick) {
            const btn = document.createElement('button');
            btn.className = "text-gray-600 hover:bg-gray-100 p-1 rounded w-8 h-8 flex items-center justify-center";
            btn.innerHTML = html;
            btn.onclick = onClick;
            return btn;
        }

        function createColorInput(title, onChange, iconHtml) {
            const wrapper = document.createElement('div');
            wrapper.className = "relative inline-block w-8 h-8";

            const icon = document.createElement('div');
            icon.className = "absolute inset-0 flex items-center justify-center pointer-events-none text-gray-600";
            icon.innerHTML = iconHtml;

            const input = document.createElement('input');
            input.type = 'color';
            input.className = "opacity-0 w-full h-full cursor-pointer";
            input.oninput = (e) => onChange(e.target.value);

            wrapper.appendChild(input);
            wrapper.appendChild(icon);
            return wrapper;
        }

        // --- FORMATTING LOGIC ---
        function applyStyle(key, value) {
            // New Cell-Based Logic
            if (State.selectedCells.size === 0) return;

            State.selectedCells.forEach(cellKey => {
                const [taskId, colId] = cellKey.split(':');
                const task = State.tasks.find(t => t.id === taskId);
                if (task) {
                    if (!task.cellStyles) task.cellStyles = {};
                    if (!task.cellStyles[colId]) task.cellStyles[colId] = {};

                    task.cellStyles[colId][key] = value;
                    triggerAutoSave(task.id);
                }
            });
            render();
        }

        // --- GRID INTERACTION CONTROLLER ---
        const GridController = {
            lastClickTime: 0,
            lastClickId: null,

            handleMouseDown(e, task, colId) {
                if (e.button !== 0) return; // Only Left Click

                // MANUAL DOUBLE CLICK DETECTION (Because Render wipes DOM)
                const now = Date.now();
                const cellKey = `${task.id}:${colId}`;
                if (cellKey === this.lastClickId && (now - this.lastClickTime < 300)) {
                    // Detected Double Click!
                    const col = Config.columns.find(c => c.id === colId);
                    if (col && col.editable) {
                        e.preventDefault();
                        e.stopPropagation(); // Stop DblClick
                        State.activeCell = { taskId: task.id, colId: colId };
                        enterEditMode();
                        this.lastClickId = null; // Reset
                        return;
                    }
                }
                this.lastClickId = cellKey;
                this.lastClickTime = now;


                // If in Edit Mode, clicking outside commits.
                // If clicking inside editor, don't interfere.
                if (State.interactionMode === 'EDITING') {
                    if (e.target.id === 'active-editor') return; // Clicking inside input
                    // Clicking outside -> Commit
                    commitEdit();
                    State.interactionMode = 'NAVIGATION';
                    // Continue to select new cell
                }

                // If clicking fill handle (logic handled separately or check target class)
                if (e.target.classList.contains('fill-handle')) {
                    this.startFill(e);
                    return;
                }

                State.isDragging = true;
                State.isFilling = false;

                // Prevent Default Text Selection
                // e.preventDefault(); // CAUTION: Might block Focus? No, we use user-select: none.

                // Update Mode
                State.interactionMode = 'SELECTING';

                State.interactionMode = 'SELECTING';

                // cellKey already defined above


                if (e.ctrlKey) {
                    // Add/Remove
                    if (State.selectedCells.has(cellKey)) {
                        State.selectedCells.delete(cellKey);
                    } else {
                        State.selectedCells.add(cellKey);
                        State.activeCell = { taskId: task.id, colId };
                    }
                    State.anchorCell = { taskId: task.id, colId };
                } else if (e.shiftKey && State.activeCell) {
                    // Range Select
                    this.selectRange(State.activeCell, { taskId: task.id, colId });
                } else {
                    // Single Select
                    State.selectedCells.clear();
                    State.selectedCells.add(cellKey);
                    State.activeCell = { taskId: task.id, colId };
                    State.anchorCell = { taskId: task.id, colId };
                }

                render(); // Update Visuals
            },

            handleMouseEnter(e, task, colId) {
                if (State.isDragging && !State.isFilling) {
                    // Update Range Selection from Anchor to Current
                    this.selectRange(State.anchorCell, { taskId: task.id, colId });
                    render();
                }
                if (State.isFilling) {
                    // Update Target Range
                    const src = State.fillSourceRange;
                    if (!src) return;

                    // Determine Target Range based on Mouse Position vs Source
                    // We only support Vertical Fill for now
                    const targetTask = State.tasks.find(t => t.id === task.id);
                    if (!targetTask) return;

                    let startRow = src.startRow;
                    let endRow = src.endRow;

                    if (targetTask.orderIndex > src.endRow) {
                        // Dragging Down
                        endRow = targetTask.orderIndex;
                    } else if (targetTask.orderIndex < src.startRow) {
                        // Dragging Up (Optional? for now focus on Down)
                        startRow = targetTask.orderIndex;
                    }

                    State.fillTargetRange = { startRow, endRow };

                    // Visual Feedback: Select Target Cells temporarily?
                    // Or add specific class 'fill-target'?
                    // For now, let's just select them to show scope
                    // But "Selection" usually implies source. 
                    // Excel keeps source selected and adds border to target.
                    // We'll stick to simple selection expansion for now to save complexity.
                    this.selectRange(
                        { taskId: State.tasks[startRow].id, colId: State.activeCell.colId }, // Approx
                        { taskId: State.tasks[endRow].id, colId: State.activeCell.colId }
                    );
                    render();
                }
            },

            handleMouseUp() {
                if (State.isFilling) {
                    this.executeFill();
                }
                State.isDragging = false;
                State.isFilling = false;
                State.fillSourceRange = null;
                State.fillTargetRange = null;
            },

            selectRange(start, end) {
                State.selectedCells.clear();

                const startTask = State.tasks.find(t => t.id === start.taskId);
                const endTask = State.tasks.find(t => t.id === end.taskId);
                if (!startTask || !endTask) return;

                const startIdx = Math.min(startTask.orderIndex, endTask.orderIndex);
                const endIdx = Math.max(startTask.orderIndex, endTask.orderIndex);

                const cols = Config.columns.map(c => c.id);
                const c1 = cols.indexOf(start.colId);
                const c2 = cols.indexOf(end.colId);
                const startCol = Math.min(c1, c2);
                const endCol = Math.max(c1, c2);

                for (let r = startIdx; r <= endIdx; r++) {
                    const t = State.tasks[r];
                    if (!t) continue;
                    for (let c = startCol; c <= endCol; c++) {
                        State.selectedCells.add(`${t.id}:${cols[c]}`);
                    }
                }
            },

            startFill(e) {
                State.isFilling = true;
                State.isDragging = true;
                e.stopPropagation();

                // Calculate Source Range from Selection
                const indices = [];
                State.selectedCells.forEach(k => {
                    const [tid] = k.split(':');
                    const t = State.tasks.find(x => x.id === tid);
                    if (t) indices.push(t.orderIndex);
                });

                if (indices.length === 0) return;

                const minRow = Math.min(...indices);
                const maxRow = Math.max(...indices);

                State.fillSourceRange = {
                    startRow: minRow,
                    endRow: maxRow
                };
                // Initial Target is Source
                State.fillTargetRange = { ...State.fillSourceRange };
            },

            executeFill() {
                if (!State.fillSourceRange || !State.fillTargetRange) return;

                const src = State.fillSourceRange; // {startRow, endRow, ...}
                const tgt = State.fillTargetRange; // {startRow, endRow, ...}

                // For each selected column
                const sCells = Array.from(State.selectedCells);
                if (sCells.length === 0) return;

                // Group by Col
                const cols = new Set(sCells.map(k => k.split(':')[1]));

                cols.forEach(colId => {
                    // Get Source Values
                    const sourceValues = [];
                    for (let r = src.startRow; r <= src.endRow; r++) {
                        const tHash = State.tasks[r];
                        if (tHash) sourceValues.push(tHash[colId]);
                    }

                    // Detect Pattern
                    // Simple logic: if all numbers, check increment. If mixed or text, repeat sequence.
                    let isNumeric = sourceValues.every(v => !isNaN(parseFloat(v)) && isFinite(v));
                    let increment = 0;

                    if (isNumeric && sourceValues.length > 1) {
                        const n1 = parseFloat(sourceValues[0]);
                        const n2 = parseFloat(sourceValues[1]);
                        increment = n2 - n1;
                        // Verify consistency? Assume linear for now.
                    }

                    // Fill Target
                    let srcIdx = 0;
                    let lastVal = parseFloat(sourceValues[sourceValues.length - 1]);

                    for (let r = tgt.startRow; r <= tgt.endRow; r++) {
                        const targetTask = State.tasks[r];
                        if (!targetTask) continue;

                        let newVal;

                        if (isNumeric && sourceValues.length > 1) {
                            // Continue Pattern
                            lastVal += increment;
                            newVal = lastVal;
                            // Format back to string if needed?
                            // If duration, suffix 'días'? Duration logic handles raw numbers usually?
                            // 'duration' column logic: "5 días".
                            if (colId === 'duration') {
                                // Duration special handling?
                                // stored as '5 días'?
                                // Let's check getter... val = diffDays + ' días'.
                                // So sourceValues are strings "5 días".
                                // isNumeric will be false.
                            }
                        } else {
                            // Repeat Sequence
                            newVal = sourceValues[srcIdx % sourceValues.length];
                            srcIdx++;
                        }

                        // Apply
                        // Special Handling for Duration/Dates
                        if (colId === 'duration') {
                            // parse "5 días" -> 5
                            const days = parseInt(newVal) || 0;
                            if (targetTask.start && days > 0) {
                                const d = new Date(targetTask.start);
                                d.setDate(d.getDate() + days);
                                targetTask.end = d.toISOString().split('T')[0];
                            }
                        } else if (colId === 'start') {
                            // Date logic? For now strict copy.
                            targetTask.start = newVal;
                            // Update Duration?
                        } else {
                            targetTask[colId] = newVal;
                        }
                        triggerAutoSave(targetTask.id);
                    }
                });

                HierarchyEngine.recalculate(State.tasks);
                render();
            }
        };

        // --- DOUBLE CLICK TO EDIT ---
        document.getElementById('main-table').addEventListener('dblclick', (e) => {
            // Find cell
            const td = e.target.closest('td');
            if (!td) return;

            // Extract task/col
            const tr = td.parentElement;
            const taskId = tr.getAttribute('data-task-id');

            // Col Index?
            const children = Array.from(tr.children);
            const colIndex = children.indexOf(td);

            if (taskId && colIndex >= 0) {
                const col = Config.columns[colIndex];
                if (col && col.editable) {
                    State.activeCell = { taskId, colId: col.id };
                    enterEditMode();
                }
            }
        });

        document.addEventListener('mouseup', () => GridController.handleMouseUp());

        // --- OLD FORMATTING LOGIC (MIGRATED ABOVE) ---
        // keeping helpers
        function toggleBold() {
            // check cell styles? 
            // Just toggle active cell's style
            if (State.selectedCells.size > 0) {
                // Check if first is bold
                const firstKey = Array.from(State.selectedCells)[0];
                const [tid, cid] = firstKey.split(':');
                const task = State.tasks.find(t => t.id === tid);
                const isBold = task.cellStyles && task.cellStyles[cid] && task.cellStyles[cid].fontWeight === 'bold';
                applyStyle('fontWeight', isBold ? 'normal' : 'bold');
            }
        }

        function changeFill(color) { applyStyle('backgroundColor', color); }
        function changeTextColor(color) { applyStyle('color', color); }
        function changeFontSize(size) { applyStyle('fontSize', size + 'px'); }

        // --- AUTO-SAVE LOGIC ---
        function triggerAutoSave(taskId) {
            State.dirtyTasks.add(taskId);

            const status = document.getElementById('save-status');
            if (status) {
                status.innerText = "Guardando...";
                status.classList.remove('text-green-500');
                status.classList.add('text-orange-400');
            }

            if (State.autoSaveTimer) clearTimeout(State.autoSaveTimer);
            State.autoSaveTimer = setTimeout(saveDirtyTasks, 1500); // 1.5s debounce
        }

        async function saveProjectSettings() {
            const payload = {
                settings: {
                    companyColors: State.companyColors
                }
            };

            try {
                const res = await fetch(`/api/projects/{{ project.id }}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!res.ok) console.error("Failed to save settings");
            } catch (e) {
                console.error("Error saving settings", e);
            }
        }

        async function saveDirtyTasks() {
            if (State.dirtyTasks.size === 0) return;

            const tasksToSave = Array.from(State.dirtyTasks);
            State.dirtyTasks.clear(); // Optimistic clear

            console.log("AO Gantt: Auto-Saving", tasksToSave.length, "tasks");

            // We save sequentially or parallel? Parallel is fine.
            // Ideally backend supports bulk update, but we have /api/activities/{id}

            const promises = tasksToSave.map(async (id) => {
                const task = State.tasks.find(t => t.id === id);
                if (!task) return;

                // Construct Payload
                const styleObj = task.style || {};
                styleObj.level = task.level;
                styleObj.collapsed = task.collapsed;
                styleObj.index = task.orderIndex; // Persist Sort Order

                // SANITIZATION
                let cleanProgress = parseFloat(task.progress);
                if (isNaN(cleanProgress)) cleanProgress = 0;

                let cleanStart = task.start;
                if (cleanStart && cleanStart.includes('T')) cleanStart = cleanStart.split('T')[0];

                let cleanEnd = task.end;
                if (cleanEnd && cleanEnd.includes('T')) cleanEnd = cleanEnd.split('T')[0];

                const payload = {
                    name: task.name,
                    start: cleanStart,
                    end: cleanEnd,
                    progress: cleanProgress,
                    contractor: task.contractor,
                    style: JSON.stringify(styleObj),
                    cell_styles: JSON.stringify(task.cellStyles || {}),
                    comments: task.comments || [],
                    display_order: task.orderIndex,
                    extension_days: parseInt(task.extension_days) || 0
                };

                try {
                    // FIX: Use server_id (Unique DB ID) if available, else id
                    const targetId = task.server_id ? task.server_id : id;
                    const res = await fetch(`/api/activities/${targetId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!res.ok) {
                        const errText = await res.text();
                        console.error("Save Failed for", id, res.status, errText);
                        // alert(`Error guardando tarea: ${res.status} - ${errText}`); // Suppress alert for smooth UX
                        State.dirtyTasks.add(id); // Re-add
                    }
                } catch (e) {
                    console.error("Network Error saving", id, e);
                    State.dirtyTasks.add(id);
                }
            });

            await Promise.all(promises);

            const status = document.getElementById('save-status');
            if (status) {
                if (State.dirtyTasks.size === 0) {
                    status.innerText = "Guardado";
                    status.classList.remove('text-orange-400');
                    status.classList.add('text-green-500');
                } else {
                    status.innerText = "Reintentando...";
                    status.classList.add('text-red-500');
                }
            }
        }

        function createSeparator() {
            const sep = document.createElement('div');
            sep.style.width = '1px'; sep.style.height = '24px'; sep.style.background = '#e5e7eb'; sep.style.margin = '0 10px';
            return sep;
        }

        // Expose globally for button access
        window.saveAll = forceSaveAll;

        async function forceSaveAll() {


            const btn = document.getElementById('btn-save-all');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Guardando...';
            btn.disabled = true;

            // 1. Mark ALL tasks as dirty
            State.tasks.forEach(t => State.dirtyTasks.add(t.id));

            // 2. Save Settings
            await saveProjectSettings();

            // 3. Save Tasks
            await saveDirtyTasks();

            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.disabled = false;
                alert("Guardado completo.");
            }, 500);
        }

        // --- IMPORT LOGIC V2 (Cache Buster) ---
        // Expose explicitly to window to avoid Scope/ReferenceErrors
        window.handleFileUploadV2 = async function (e) {
            // DEBUG ALERT TO CONFIRM EXECUTION
            // alert("DEBUG: Inicio de Importación V2");

            const debugEl = document.getElementById('save-status');
            if (debugEl) debugEl.innerHTML = '<span class="text-blue-600">Iniciando...</span>';

            console.log("AO Gantt: Import V2 Triggered");

            // Scope variables for finally block
            let btn = null;
            let originalText = 'Importar';

            try {
                // Validate Event
                if (!e || !e.target || !e.target.files) {
                    const msg = "Error: Evento inválido. Recarga la página (Ctrl+F5).";
                    if (debugEl) debugEl.innerHTML = `<span class="text-red-600 font-bold">${msg}</span>`;
                    alert(msg);
                    return;
                }

                const file = e.target.files[0];
                if (!file) {
                    if (debugEl) debugEl.innerHTML = 'Cancelado';
                    return;
                }

                if (!confirm(`¿Importar ${file.name}? Esto reemplezará la versión actual.`)) {
                    e.target.value = '';
                    if (debugEl) debugEl.innerHTML = 'Cancelado por usuario';
                    return;
                }

                if (debugEl) debugEl.innerHTML = '<span class="text-orange-500"><i class="fas fa-spinner fa-spin"></i> Enviando...</span>';

                const formData = new FormData();
                formData.append('file', file);

                const urlParts = window.location.pathname.split('/');
                const projectId = urlParts[urlParts.length - 1];

                // Button UI Update
                btn = e.target.previousElementSibling;
                // Fallback search
                if (!btn || btn.tagName !== 'BUTTON') {
                    btn = document.querySelector('button[onclick*="file-upload"]');
                }

                if (btn) {
                    originalText = btn.innerHTML;
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                    btn.disabled = true;
                }

                // FETCH
                console.log("AO Gantt: Sending POST to /api/projects/" + projectId + "/schedule");

                const res = await fetch(`/api/projects/${projectId}/schedule`, {
                    method: 'POST',
                    body: formData
                });

                console.log("AO Gantt: Response", res.status);

                if (res.ok) {
                    if (debugEl) debugEl.innerHTML = '<span class="text-green-600 font-bold">¡Éxito! Recargando...</span>';
                    alert('Importación exitosa. Recargando...');
                    window.location.reload();
                } else {
                    const err = await res.json();
                    const errMsg = err.detail || 'Error desconocido';
                    if (debugEl) debugEl.innerHTML = `<span class="text-red-600 font-bold">Error: ${errMsg}</span>`;
                    alert('Error del Servidor: ' + errMsg);

                    if (res.status === 401) {
                        window.location.href = '/auth/login';
                    }
                }
            } catch (err) {
                console.error(err);
                if (debugEl) debugEl.innerHTML = `<span class="text-red-600 font-bold">Crash: ${err.message}</span>`;
                alert('Error Crítico Frontend: ' + err.message);
            } finally {
                if (e && e.target) e.target.value = '';
                // Restore button
                if (btn) {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
            }
        }

        // --- COMPANIES LOGIC ---
        function openCompanyModal() {
            const contractors = new Set();
            State.tasks.forEach(t => {
                const c = t.contractor;
                if (c && c.trim() !== '' && c !== 'N/A') contractors.add(c.trim());
            });
            // Also add from companyColors keys (manual adds)
            Object.keys(State.companyColors).forEach(k => contractors.add(k));

            let overlay = document.getElementById('modal-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'modal-overlay';
                overlay.className = "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50";
                document.body.appendChild(overlay);
            }
            overlay.innerHTML = '';

            const modal = document.createElement('div');
            modal.className = "bg-white rounded-lg shadow-xl w-96 max-h-[80vh] flex flex-col";

            const header = document.createElement('div');
            header.className = "px-6 py-4 border-b flex justify-between items-center";
            header.innerHTML = '<h3 class="text-lg font-bold text-gray-800">Gestión de Empresas</h3><button onclick="closeModal()" class="text-gray-400 hover:text-gray-600"><i class="fas fa-times"></i></button>';
            modal.appendChild(header);

            // --- NEW: Add Company Section ---
            const addIdx = document.createElement('div');
            addIdx.className = "px-6 py-3 border-b bg-gray-50 flex space-x-2";
            const inputNew = document.createElement('input');
            inputNew.placeholder = "Nueva Empresa...";
            inputNew.className = "border rounded px-2 py-1 text-sm flex-1";

            const btnAdd = document.createElement('button');
            btnAdd.className = "bg-green-500 text-white px-3 py-1 rounded text-sm hover:bg-green-600";
            btnAdd.innerText = "+";
            btnAdd.onclick = () => {
                const val = inputNew.value.trim();
                if (val) {
                    if (!State.companyColors[val]) {
                        State.companyColors[val] = getRandomColor();
                        // Force re-render of modal
                        openCompanyModal();
                    }
                }
            };
            addIdx.appendChild(inputNew);
            addIdx.appendChild(btnAdd);
            modal.appendChild(addIdx);
            // --------------------------------

            // --- NEW: Global Visibility Controls ---
            const controls = document.createElement('div');
            controls.className = "px-6 py-2 bg-gray-100 border-b flex space-x-3 text-xs";

            const btnAll = document.createElement('button');
            btnAll.className = "text-blue-600 hover:text-blue-800 font-medium";
            btnAll.innerText = "Seleccionar Todo";
            btnAll.onclick = () => {
                State.hiddenContractors.clear();
                openCompanyModal(); // Re-render modal
                render(); // Re-render Gantt
            };

            const btnNone = document.createElement('button');
            btnNone.className = "text-blue-600 hover:text-blue-800 font-medium";
            btnNone.innerText = "Deseleccionar Todo";
            btnNone.onclick = () => {
                contractors.forEach(c => State.hiddenContractors.add(c));
                openCompanyModal();
                render();
            };

            controls.appendChild(btnAll);
            controls.appendChild(btnNone);
            modal.appendChild(controls);
            // ---------------------------------------

            const body = document.createElement('div');
            body.className = "p-6 overflow-y-auto flex-1";

            if (contractors.size === 0) {
                body.innerHTML = '<p class="text-gray-500 italic text-center">No hay empresas. Agrega una arriba.</p>';
            } else {
                contractors.forEach(c => {
                    const row = document.createElement('div');
                    row.className = "flex items-center justify-between mb-3";

                    const left = document.createElement('div');
                    left.className = "flex items-center";

                    // VISIBILITY CHECKBOX
                    const check = document.createElement('input');
                    check.type = 'checkbox';
                    check.className = "mr-3 w-4 h-4 text-blue-600 rounded";
                    check.checked = !State.hiddenContractors.has(c);
                    check.onchange = (e) => {
                        if (e.target.checked) {
                            State.hiddenContractors.delete(c);
                        } else {
                            State.hiddenContractors.add(c);
                        }
                        render();
                    };

                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.className = "w-6 h-6 rounded cursor-pointer border-0 mr-3 p-0";
                    // Get existing or assign default
                    if (!State.companyColors[c]) State.companyColors[c] = stringToColor(c);
                    colorInput.value = State.companyColors[c];
                    colorInput.onchange = (e) => {
                        State.companyColors[c] = e.target.value;
                        saveProjectSettings(); // Save change
                        render(); // Re-render Gantt to update bars
                    };

                    const name = document.createElement('span');
                    name.className = "text-sm font-medium text-gray-700";
                    name.innerText = c;

                    // Assign Button (For Selection)
                    const btnAssign = document.createElement('button');
                    btnAssign.className = "ml-2 text-xs text-blue-500 hover:text-blue-700 underline";
                    btnAssign.innerText = "Asignar";
                    btnAssign.onclick = () => {
                        // Assign 'c' to all selected tasks
                        if (State.selectedIds.size === 0) {
                            alert("Selecciona tareas en el Gantt primero.");
                            return;
                        }
                        State.selectedIds.forEach(id => {
                            const t = State.tasks.find(tk => tk.id === id);
                            if (t) {
                                t.contractor = c;
                                triggerAutoSave(t.id);
                            }
                        });
                        render();
                        // Optional: Highlight success?
                    };

                    left.appendChild(check); // Add checkbox
                    left.appendChild(colorInput);
                    left.appendChild(name);
                    left.appendChild(btnAssign);
                    row.appendChild(left);
                    body.appendChild(row);
                });
            }
            modal.appendChild(body);

            const footer = document.createElement('div');
            footer.className = "px-6 py-4 border-t bg-gray-50 flex justify-end";
            footer.innerHTML = '<button onclick="closeModal()" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Cerrar</button>';
            modal.appendChild(footer);

            overlay.appendChild(modal);
            overlay.style.display = 'flex';
        }

        window.closeModal = function () {
            document.getElementById('modal-overlay').style.display = 'none';
        }

        window.openTaskBoard = function () {
            // 1. Force Save to ensure backend has latest edits
            forceSaveAll();

            // 2. Get Params
            const start = State.lookAheadStart || new Date();
            const weeks = State.lookAheadWeeks || 3;

            const yyyy = start.getFullYear();
            const mm = String(start.getMonth() + 1).padStart(2, '0');
            const dd = String(start.getDate()).padStart(2, '0');
            const dateStr = `${yyyy}-${mm}-${dd}`;

            // 3. Open
            const url = `/projects/{{ project.id }}/tasks-board?start=${dateStr}&weeks=${weeks}`;
            window.open(url, '_blank');
        }


        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = str.charCodeAt(i) + ((hash << 5) - hash);
            }
            let color = '#';
            for (let i = 0; i < 3; i++) {
                let value = (hash >> (i * 8)) & 0xFF;
                color += ('00' + value.toString(16)).substr(-2);
            }
            return color;
        }

        function scrollToToday() {
            const todayX = timeToX(new Date());
            const scroll = document.getElementById('master-scroll');
            const centerOffset = scroll.clientWidth / 2; // Center it
            // Adjust for sticky headers... assumes sticky headers are approx 600px
            const stickyW = getTotalStickyWidth();

            // We want Today to be at stickyW + (visible_gantt / 2)
            // scrollLeft controls the Gantt view offset.
            // Actually, sticky table means scrollLeft moves the whole table.

            scroll.scrollLeft = todayX - (scroll.clientWidth / 2) + stickyW;
        }

        // --- HIERARCHY ENGINE (Project-Like) ---
        const HierarchyEngine = {
            recalculate(tasks) {
                // 1. Reset
                tasks.forEach((t, i) => {
                    t.isSummary = false;
                    t.childrenIds = [];
                    t.parentId = null;
                    t.wbs = '';
                    t.orderIndex = i;
                });

                // 2. Build Tree
                const parentStack = [];

                tasks.forEach(task => {
                    const level = task.level;
                    parentStack[level] = task;

                    if (level > 0 && parentStack[level - 1]) {
                        const parent = parentStack[level - 1];
                        parent.childrenIds.push(task.id);
                        parent.isSummary = true;
                        task.parentId = parent.id;
                    }
                    // Clear deep stack
                    for (let l = level + 1; l < parentStack.length; l++) {
                        parentStack[l] = null;
                    }
                });

                // 3. Rollup Calculations (Bottom-Up)
                // We need to process from deep levels up or use recursion.
                // Since we have childrenIds, recursion is easy.
                const topLevel = tasks.filter(t => !t.parentId);
                topLevel.forEach(t => this.rollup(t));
            },

            rollup(task) {
                if (!task.childrenIds || task.childrenIds.length === 0) return;

                const children = task.childrenIds.map(id => State.tasks.find(t => t.id === id)).filter(Boolean);

                // Recurse first
                children.forEach(c => this.rollup(c));

                // Calculate Stats
                let minStart = null;
                let maxEnd = null;
                let totalProgress = 0;
                let validProgressCount = 0;

                children.forEach(c => {
                    if (c.start) {
                        const s = new Date(c.start);
                        if (!minStart || s < minStart) minStart = s;
                        // For summary end: usually max of ends.
                        // If c.end is missing, maybe assume c.start?
                    }
                    if (c.end) {
                        const e = new Date(c.end);
                        if (!maxEnd || e > maxEnd) maxEnd = e;
                    }

                    let p = parseFloat(c.progress);
                    if (isNaN(p)) p = 0;
                    totalProgress += p;
                    validProgressCount++;
                });

                if (minStart) task.start = minStart.toISOString().split('T')[0];
                if (maxEnd) task.end = maxEnd.toISOString().split('T')[0];
                if (validProgressCount > 0) {
                    task.progress = Math.round(totalProgress / validProgressCount);
                } else {
                    task.progress = 0;
                }

                // Duration matches date range? Or sum of durations?
                // Visual Gantt usually implies duration = End - Start.
                // Project usually does End - Start.
                // We don't explicitely set 'duration' field here because the getter calculates it?
                // Let's check getter in renderBody: 
                // if (col.id === 'duration') ... const diffDays = ...
                // So updating start/end is sufficient for duration column.
            },

            toggleCollapse(taskId) {
                const task = State.tasks.find(t => t.id === taskId);
                if (task && task.isSummary) {
                    task.collapsed = !task.collapsed;
                    render();
                }
            },

            // --- CORE SELECTION LOGIC ---
            getSelectionSegments() {
                // 1. Normalize Selection: Get all selected Tasks
                let selectedTasks = State.tasks.filter(t => State.selectedIds.has(t.id));
                if (selectedTasks.length === 0) return [];

                // 2. Expand Subtrees (If parent selected, include all children recursively)
                const fullSelectionSet = new Set();

                selectedTasks.forEach(task => {
                    fullSelectionSet.add(task);
                    // Include subtree
                    const subtree = this.getSubtree(task);
                    subtree.forEach(child => fullSelectionSet.add(child));
                });

                // Convert back to Array and Sort by Order
                const finalSelection = Array.from(fullSelectionSet).sort((a, b) => a.orderIndex - b.orderIndex);

                // 3. Group into Contiguous Segments
                const segments = [];
                let currentSegment = [];

                finalSelection.forEach((task, i) => {
                    if (currentSegment.length === 0) {
                        currentSegment.push(task);
                    } else {
                        const prev = currentSegment[currentSegment.length - 1];
                        if (task.orderIndex === prev.orderIndex + 1) {
                            currentSegment.push(task);
                        } else {
                            segments.push(currentSegment);
                            currentSegment = [task];
                        }
                    }
                });
                if (currentSegment.length > 0) segments.push(currentSegment);

                return segments;
            },

            // Helper for subtree
            getSubtree(parent) {
                let list = [];
                if (parent.childrenIds) {
                    parent.childrenIds.forEach(cid => {
                        const c = State.tasks.find(x => x.id === cid);
                        if (c) {
                            list.push(c);
                            list = list.concat(this.getSubtree(c));
                        }
                    });
                }
                return list;
            },

            indent() {
                const rows = this.getSelectedRows();
                if (rows.length === 0) return;

                rows.sort((a, b) => a.orderIndex - b.orderIndex);

                let changed = false;
                const first = rows[0];
                const prev = State.tasks[first.orderIndex - 1];
                if (!prev) return;

                rows.forEach(t => {
                    t.level = (t.level || 0) + 1;
                    changed = true;
                });

                if (changed) {
                    this.recalculate(State.tasks);
                    State.tasks.forEach(t => { if (rows.includes(t)) triggerAutoSave(t.id); });
                    render();
                }
            },

            outdent() {
                const rows = this.getSelectedRows();
                if (rows.length === 0) return;

                rows.forEach(t => {
                    if (t.level > 0) {
                        t.level--;
                        triggerAutoSave(t.id);
                    }
                });
                this.recalculate(State.tasks);
                render();
            },

            getSelectedRows() {
                const ids = new Set();
                State.selectedCells.forEach(k => ids.add(k.split(':')[0]));
                return Array.from(ids).map(id => State.tasks.find(t => t.id === id)).filter(Boolean);
            }
        };


        // --- GLOBAL KEYS & NAVIGATION ---
        function handleGlobalKeys(e) {
            if (State.interactionMode === 'EDITING') {
                if (e.key === 'Enter') {
                    // Commit & Exit
                    commitEdit();
                    State.interactionMode = 'NAVIGATION';
                    render();
                } else if (e.key === 'Escape') {
                    // Cancel & Exit
                    State.interactionMode = 'NAVIGATION';
                    render();
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    commitEdit();
                    moveSelection(0, e.shiftKey ? -1 : 1);
                    State.interactionMode = 'NAVIGATION';
                    render();
                }
                return; // Let input handle other keys
            }

            // NAVIGATION MODE
            if (State.interactionMode === 'NAVIGATION' || State.interactionMode === 'SELECTING') {
                if (e.key.startsWith('Arrow')) {
                    e.preventDefault();
                    let dr = 0, dc = 0;
                    if (e.key === 'ArrowUp') dr = -1;
                    if (e.key === 'ArrowDown') dr = 1;
                    if (e.key === 'ArrowLeft') dc = -1;
                    if (e.key === 'ArrowRight') dc = 1;

                    if (e.shiftKey) {
                        // Expand selection (Anchor stays)
                        if (State.activeCell) {
                            const tasks = State.tasks; // assuming flat list matching orderIndex
                            // Find current End
                            // This is complex because we need to know current "End".
                            // Simplify: just move "End" logic?
                            // Excel Shift+Arrow moves the "Floating" end of selection.
                            // We need to track `selectionEnd`.
                            // For now, let's keep simple arrow navigaton. Shift logic can be added if needed seriously.
                            // Basic Navigation:
                            moveSelection(dr, dc);
                        }
                    } else {
                        // Move Active Cell
                        moveSelection(dr, dc);
                    }
                } else if (e.key === 'Enter' || e.key === 'F2') {
                    e.preventDefault();
                    enterEditMode();
                } else if (e.key === 'Delete' || e.key === 'Backspace') {
                    // Clear content
                    if (State.selectedCells.size > 0) {
                        State.selectedCells.forEach(k => {
                            const [tid, cid] = k.split(':');
                            const t = State.tasks.find(tk => tk.id === tid);
                            if (t && Config.columns.find(c => c.id === cid).editable) {
                                t[cid] = '';
                                triggerAutoSave(t.id);
                            }
                        });
                        render();
                    }
                } else if (e.key === 'a' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    // Select All?
                }

                // Indent ShortCuts
                if (e.altKey && e.shiftKey) {
                    if (e.key === 'ArrowRight') HierarchyEngine.indent();
                    if (e.key === 'ArrowLeft') HierarchyEngine.outdent();
                }
            }
        }

        function moveSelection(dr, dc) {
            if (!State.activeCell) return;
            const { taskId, colId } = State.activeCell;
            const task = State.tasks.find(t => t.id === taskId);
            if (!task) return;

            const rIdx = task.orderIndex + dr;
            const cols = Config.columns.map(c => c.id);
            const cIdx = cols.indexOf(colId) + dc;

            if (rIdx >= 0 && rIdx < State.tasks.length && cIdx >= 0 && cIdx < cols.length) {
                const nextTask = State.tasks[rIdx];
                const nextCol = cols[cIdx];

                // If Shift?? For now just moving active cell clears selection
                if (!State.isDragging) { // IsDragging check irrelevant here
                    State.selectedCells.clear();
                    State.selectedCells.add(`${nextTask.id}:${nextCol}`);
                    State.activeCell = { taskId: nextTask.id, colId: nextCol };
                    State.anchorCell = { taskId: nextTask.id, colId: nextCol };
                    render();

                    // Scroll into view logic ...
                }
            }
        }

        function enterEditMode() {
            if (!State.activeCell) return;
            const { taskId, colId } = State.activeCell;

            // Check if editable
            const col = Config.columns.find(c => c.id === colId);
            if (!col || !col.editable) return;

            State.interactionMode = 'EDITING';
            render();

            // Focus Input
            setTimeout(() => {
                const input = document.getElementById('active-editor');
                if (input) {
                    input.focus();
                    input.select(); // Select all text like Excel
                }
            }, 10);
        }

        function commitEdit() {
            const input = document.getElementById('active-editor');
            if (!input || !State.activeCell) return;

            const val = input.value;
            const { taskId, colId } = State.activeCell;
            const task = State.tasks.find(t => t.id === taskId);

            if (task) {
                updateTaskValue(task, colId, val);
            }
        }

        function selectRow(task, mode) { // mode: 'single', 'multi', 'range'
            if (mode === 'single') {
                State.selectedIds.clear();
                State.selectedIds.add(task.id);
            } else if (mode === 'multi') {
                if (State.selectedIds.has(task.id)) State.selectedIds.delete(task.id);
                else State.selectedIds.add(task.id);
            } else {
                State.selectedIds.add(task.id);
            }
            State.lastSelectedId = task.id;
            render();
        }

        // --- Helper for updating task ---
        function updateTaskValue(task, colId, newVal) {
            if (colId === 'duration') {
                const days = parseInt(newVal) || 0;
                if (task.start && days > 0) {
                    const d = new Date(task.start);
                    d.setDate(d.getDate() + days);
                    task.end = d.toISOString().split('T')[0];
                    triggerAutoSave(task.id);
                    HierarchyEngine.recalculate(State.tasks);
                    render();
                }
            } else if (colId === 'start') {
                task.start = newVal;
                triggerAutoSave(task.id);
                HierarchyEngine.recalculate(State.tasks);
                render();
            } else if (colId === 'end') {
                task.end = newVal;
                triggerAutoSave(task.id);
                HierarchyEngine.recalculate(State.tasks);
                render();
            } else {
                task[colId] = newVal;
                triggerAutoSave(task.id);
            }
        }

        // --- RENDERERS ---
        function render() {
            renderHeader();
            renderBody();
            renderOverlays(); // Today Line & Look Ahead
        }

        function renderOverlays() {
            // New function to draw overlays on top of the bars
            // We'll reuse dependency-svg or creating a new "overlay-svg" on top?
            // Let's use 'dependency-svg' as it is already absolutely positioned.

            let svg = document.getElementById('dependency-svg');
            if (!svg) return; // Should exist by now

            // Clear previous overlays (but keep deps if we had them? We don't have deps yet)
            // For now, clear all because we redraw fresh
            svg.innerHTML = '';

            // 1. TODAY LINE
            const todayX = timeToX(new Date());
            if (todayX >= 0 && todayX <= State.totalWidth) {
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute('x1', todayX); line.setAttribute('y1', 0);
                line.setAttribute('x2', todayX); line.setAttribute('y2', svg.clientHeight);
                line.setAttribute('stroke', 'red');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('stroke-dasharray', '4');
                svg.appendChild(line);

                // Label "Today"
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute('x', todayX + 4); text.setAttribute('y', 12);
                text.textContent = "HOY";
                text.setAttribute('fill', 'red');
                text.setAttribute('font-size', '10');
                text.setAttribute('font-weight', 'bold');
                svg.appendChild(text);
            }

            // 2. LOOK AHEAD FRAME
            if (State.showLookAhead) {
                const startX = timeToX(State.lookAheadStart);
                const endDate = new Date(State.lookAheadStart);
                endDate.setDate(endDate.getDate() + (State.lookAheadWeeks * 7));
                const endX = timeToX(endDate);

                const w = endX - startX;
                if (w > 0) {
                    const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    rect.setAttribute('x', startX);
                    rect.setAttribute('y', 0);
                    rect.setAttribute('width', w);
                    rect.setAttribute('height', svg.clientHeight);
                    rect.setAttribute('fill', 'rgba(255, 0, 0, 0.05)'); // Very faint red
                    rect.setAttribute('stroke', 'red');
                    rect.setAttribute('stroke-width', '2');
                    svg.appendChild(rect);
                }
            }
        }

        function renderHeader() {
            const tr = document.getElementById('header-row');
            const timelineTh = document.getElementById('timeline-header-cell');

            // Clean logic (same as before)
            Array.from(tr.children).forEach(child => {
                if (child.id !== 'timeline-header-cell') tr.removeChild(child);
            });

            let leftOffset = 0;
            Config.columns.forEach(col => {
                const th = document.createElement('th');
                th.className = 'sticky-col';
                th.innerText = col.label;
                th.style.width = col.width + 'px';
                th.style.left = leftOffset + 'px';
                th.style.minWidth = col.width + 'px';
                const resizer = document.createElement('div');
                resizer.className = 'resizer';
                resizer.onmousedown = (e) => initResize(e, col);
                th.appendChild(resizer);
                tr.insertBefore(th, timelineTh);
                leftOffset += col.width;
            });

            State.totalWidth = calculateTotalWidth();
            timelineTh.style.width = State.totalWidth + 'px';
            timelineTh.style.minWidth = State.totalWidth + 'px';
            renderTimelineTicks(document.getElementById('timeline-svg'));
        }

        function renderTimelineTicks(svg) {
            svg.innerHTML = '';
            const zoom = State.zoom;
            let tickW = 50;

            // Tier 1 (Bottom) - The detailed tick
            // Tier 2 (Top) - The grouping tick (Month/Year)

            // CONFIG BASED ON ZOOM
            let bottomTierUnit = 'd'; // d=day, w=week, m=month
            let topTierUnit = 'm';    // m=month, y=year
            let bottomStep = 1;       // 1 day, 1 week

            if (zoom === 'DAY') { tickW = 40; bottomTierUnit = 'd'; topTierUnit = 'm'; }
            else if (zoom === 'WEEK') { tickW = 60; bottomTierUnit = 'w'; topTierUnit = 'm'; }
            else { // MONTH
                tickW = 100; bottomTierUnit = 'm'; topTierUnit = 'y';
                // Adjust pxPerMin for month view
                // 100px / (30 days * 1440 min/day) = 100 / 43200 = 0.0023148 px/min
                // This is a rough estimate. For month view, it's better to calculate based on actual month width.
            }

            // State.pxPerMin = tickW / (bottomTierUnit === 'd' ? 1440 : (bottomTierUnit === 'w' ? 10080 : 43200));
            // REFINED APPROACH: Use current pxPerMin to determine tick placement
            // Just draw ticks starting from startDate

            let curr = new Date(State.startDate);
            let x = 0;
            const H_TOP = 25;
            const H_BOT = 35; // Total 60

            // 1. Draw Bottom Tier & Grid Lines
            while (x < State.totalWidth) {
                // Determine next date and label
                let nextDate = new Date(curr);
                let label = '';

                if (zoom === 'DAY') {
                    nextDate.setDate(curr.getDate() + 1);
                    label = curr.getDate().toString();
                    // Weekday letter?
                    const days = ['D', 'L', 'M', 'X', 'J', 'V', 'S'];
                    label = days[curr.getDay()] + ' ' + label;
                } else if (zoom === 'WEEK') {
                    nextDate.setDate(curr.getDate() + 7);
                    label = `Sem ${getWeekNumber(curr)}`;
                } else { // MONTH
                    nextDate.setMonth(curr.getMonth() + 1);
                    label = curr.toLocaleDateString('es-ES', { month: 'short' });
                }

                const w = timeToX(nextDate) - timeToX(curr);

                // Rect
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute('x', x);
                rect.setAttribute('y', 30);
                rect.setAttribute('width', w);
                rect.setAttribute('height', 30);
                rect.setAttribute('fill', 'white');
                rect.setAttribute('stroke', '#e5e7eb');
                svg.appendChild(rect);

                // Text
                const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text.setAttribute('x', x + w / 2);
                text.setAttribute('y', 50);
                text.setAttribute('text-anchor', 'middle');
                text.textContent = label;
                text.setAttribute('font-size', '11');
                text.setAttribute('fill', '#6b7280');
                svg.appendChild(text);

                curr = nextDate;
                x = timeToX(curr);
            }

            // 2. Draw Top Tier (Months/Years)
            curr = new Date(State.startDate);
            x = 0;
            // Snap to first month/year boundary for smoother look? 
            // For now, just iterate safely.

            // We need to handle "Group By" rendering. 
            // Simpler approach: Iterate by Top Unit
            // But x is linear. 

            // Let's reset curr to start
            curr = new Date(State.startDate);
            // Snap curr to start of month if zoom is day/week
            if (zoom !== 'MONTH') curr.setDate(1);
            if (zoom === 'MONTH') curr.setMonth(0); // Year start

            // Adjust starting X (might be negative if startDate is mid-month)
            // We'll just draw valid months that overlap [0, totalWidth]

            let safety = 0;
            while (x < State.totalWidth && safety < 1000) {
                safety++;
                let nextTop = new Date(curr);
                let topLabel = '';

                if (zoom === 'MONTH') {
                    nextTop.setFullYear(curr.getFullYear() + 1);
                    topLabel = curr.getFullYear();
                } else { // DAY/WEEK -> Group by Month
                    nextTop.setMonth(curr.getMonth() + 1);
                    topLabel = curr.toLocaleDateString('es-ES', { month: 'long', year: 'numeric' });
                }

                const xStart = Math.max(0, timeToX(curr));
                const xEnd = timeToX(nextTop);

                if (xEnd > 0) {
                    const w = xEnd - xStart;
                    const topRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    topRect.setAttribute('x', xStart); topRect.setAttribute('y', 0);
                    topRect.setAttribute('width', w); topRect.setAttribute('height', 30);
                    topRect.setAttribute('fill', '#f9fafb'); topRect.setAttribute('stroke', '#e5e7eb');
                    svg.appendChild(topRect);

                    const topText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    topText.setAttribute('x', xStart + 10); topText.setAttribute('y', 20);
                    topText.textContent = topLabel;
                    topText.setAttribute('font-size', '12'); topText.setAttribute('font-weight', 'bold');
                    topText.setAttribute('fill', '#374151');
                    svg.appendChild(topText);
                }

                curr = nextTop;
                if (timeToX(curr) > State.totalWidth) break;
            }
        }

        function getWeekNumber(d) {
            d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
            d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
            var yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
            var weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
            return weekNo;
        }

        function renderBody() {
            const tbody = document.getElementById('table-body');
            tbody.innerHTML = '';

            // Dependency Overlay Logic
            let depSvg = document.getElementById('dependency-svg');
            const masterScroll = document.getElementById('master-scroll');
            if (!depSvg) {
                depSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                depSvg.id = 'dependency-svg';
                depSvg.style.position = 'absolute';
                depSvg.style.top = '60px';
                depSvg.style.pointerEvents = 'none';
                depSvg.style.zIndex = '10'; // Ensure overlay is on top of grid but below some tools?
                masterScroll.appendChild(depSvg);
            }
            depSvg.style.left = getTotalStickyWidth() + 'px';
            depSvg.style.width = State.totalWidth + 'px';
            depSvg.style.height = Math.max(State.tasks.length * 32, 500) + 'px';

            // Look Ahead Range
            let laStart = null, laEnd = null;
            if (State.showLookAhead) {
                laStart = State.lookAheadStart;
                laEnd = new Date(laStart);
                laEnd.setDate(laEnd.getDate() + (State.lookAheadWeeks * 7));
            }

            let hiddenLevel = -1;

            State.tasks.forEach(task => {
                // FILTER: Contractor Visibility
                if (task.contractor && State.hiddenContractors.has(task.contractor.trim())) return;


                if (hiddenLevel > -1 && task.level > hiddenLevel) return;
                if (hiddenLevel > -1 && task.level <= hiddenLevel) hiddenLevel = -1;
                if (task.isSummary && task.collapsed && hiddenLevel === -1) hiddenLevel = task.level;

                // LOOK AHEAD HIGHLIGHT LOGIC
                // Check intersection
                let isHighlighted = false;
                if (laStart && task.start && task.end) {
                    const tStart = new Date(task.start);
                    const tEnd = new Date(task.end);
                    if (tStart < laEnd && tEnd > laStart) {
                        isHighlighted = true;
                    }
                }

                const tr = document.createElement('tr');
                tr.setAttribute('data-row-index', task.orderIndex); // For context menu

                // Highlight Row (MOVED TO CELLS)
                const rowColor = (task.contractor && State.companyColors[task.contractor]) ? State.companyColors[task.contractor] : null;
                // REMOVED: Row-wide RGBA tint
                // let rgba = null; ...

                let leftOffset = 0;
                Config.columns.forEach(col => {
                    const td = document.createElement('td');
                    td.className = 'sticky-col select-none'; // select-none to prevent text selection while dragging
                    td.style.left = leftOffset + 'px';
                    td.style.width = col.width + 'px';
                    td.style.minWidth = col.width + 'px';

                    const cellKey = `${task.id}:${col.id}`;
                    const isSelected = State.selectedCells.has(cellKey);

                    if (isSelected) {
                        td.classList.add('selected-cell');
                    }

                    // NEW LOGIC: Apply Company Color ONLY to 'contractor' column
                    if (col.id === 'contractor' && rowColor) {
                        td.style.backgroundColor = rowColor;
                        // Optional: Contrast text? State.companyColors generates random, might need black/white logic.
                        // For now, keep it simple as requested: "solo la columna de empresa con el color".
                    } else if (!isSelected) {
                        // Ensure white background for others (default via CSS but explicit doesn't hurt if we had dirty state)
                        td.style.backgroundColor = 'white';
                    }

                    // Attach Events
                    td.onmousedown = (e) => GridController.handleMouseDown(e, task, col.id);
                    td.onmouseenter = (e) => GridController.handleMouseEnter(e, task, col.id);

                    if (col.id === 'name') {
                        td.style.paddingLeft = (task.level * 20 + 8) + 'px';
                        td.style.display = 'flex'; td.style.alignItems = 'center';
                        if (task.isSummary) {
                            const icon = document.createElement('i');
                            icon.className = `fas fa-caret-${task.collapsed ? 'right' : 'down'} mr-2 cursor-pointer`;
                            icon.onclick = (e) => { e.stopPropagation(); HierarchyEngine.toggleCollapse(task.id); };
                            td.appendChild(icon);
                        }
                    }

                    // RENDER CELL CONTENT
                    // Mode Check: Is this cell in EDITING mode?
                    const isEditing = State.interactionMode === 'EDITING' &&
                        State.activeCell &&
                        State.activeCell.taskId === task.id &&
                        State.activeCell.colId === col.id;

                    const div = document.createElement('div');
                    div.style.width = "100%";
                    div.style.height = "100%";
                    div.style.userSelect = "none"; // Disable text selection for drag

                    let val = task[col.id];
                    if (col.id === 'start' || col.id === 'end') val = val ? val.toString().split('T')[0] : '';
                    if (col.id === 'progress') {
                        let n = parseFloat(val);
                        if (isNaN(n)) n = 0;
                        val = Math.round(n) + '%';
                    }
                    if (col.id === 'duration') {
                        if (task.start && task.end) {
                            const d1 = new Date(task.start);
                            const d2 = new Date(task.end);
                            const diffTime = Math.abs(d2 - d1);
                            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                            val = diffDays + ' días';
                        } else {
                            val = '';
                        }
                    }

                    if (isEditing) {
                        // Render Input
                        const input = document.createElement('input');
                        input.id = 'active-editor';
                        input.type = 'text'; // or date/number based on col type
                        // Fix for 0 and stripping days: Don't use || '' because 0 is falsy but valid
                        input.value = (val !== null && val !== undefined) ? val : '';
                        if (col.id === 'duration') {
                            // Strip ' días' if present for editing
                            input.value = input.value.toString().replace(' días', '').replace(' días', '');
                        }
                        input.className = "w-full h-full border-0 outline-none p-0 bg-white text-black";
                        input.style.boxShadow = "inset 0 0 0 2px #3b82f6";

                        // Stop propagation for editing keys/clicks
                        input.onkeydown = (e) => e.stopPropagation();
                        input.onmousedown = (e) => e.stopPropagation();

                        div.appendChild(input);
                    } else {
                        // Render Text
                        div.innerText = val || '';

                        // Comment Bubble
                        if (col.id === 'name' && task.comments && task.comments.length > 0) {
                            const icon = document.createElement('i');
                            icon.className = "fas fa-comment-dots text-blue-500 ml-2";
                            icon.title = `${task.comments.length} comentarios`;
                            div.appendChild(icon);
                        }
                    }


                    // APPLY CELL STYLES
                    if (task.cellStyles && task.cellStyles[col.id]) {
                        const s = task.cellStyles[col.id];
                        if (s.fontWeight) div.style.fontWeight = s.fontWeight;
                        if (s.color) div.style.color = s.color;
                        if (s.backgroundColor) td.style.backgroundColor = s.backgroundColor;
                        if (s.fontSize) div.style.fontSize = s.fontSize;
                    }

                    td.appendChild(div);

                    /* OLD EDIT LOGIC REMOVED (contentEditable) */

                    // FILL HANDLE (If Active Cell)
                    if (State.activeCell && State.activeCell.taskId === task.id && State.activeCell.colId === col.id) {
                        const handle = document.createElement('div');
                        handle.className = 'fill-handle';
                        td.appendChild(handle);
                    }

                    tr.appendChild(td);
                    leftOffset += col.width;
                });

                const ganttTd = document.createElement('td');
                ganttTd.className = 'gantt-cell';
                const barSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                barSvg.style.width = State.totalWidth + 'px';
                barSvg.style.height = '100%';
                barSvg.style.display = 'block';

                if (task.start && task.end) {
                    const x = timeToX(task.start);
                    const w = timeToX(task.end) - x;

                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.classList.add('gantt-bar-group'); // Add class for context menu
                    g.setAttribute('data-id', task.id); // Add data-id for context menu

                    let barH = 20;
                    let barY = 6;
                    let barColor = '#3b82f6';
                    let barRadius = 3;

                    if (task.isSummary) {
                        barH = 12; barY = 6; barColor = '#000'; barRadius = 0;
                        // Summary Bar (Black Bracket)
                        const rect = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        // Draw bracket shape
                        // M x,y+h L x,y L x+w,y L x+w,y+h
                        const d = `M ${x},${barY + barH} L ${x},${barY} L ${x + w},${barY} L ${x + w},${barY + barH}`;
                        rect.setAttribute('d', d);
                        rect.setAttribute('fill', 'none');
                        rect.setAttribute('stroke', '#000');
                        rect.setAttribute('stroke-width', '2');
                        rect.setAttribute('rx', '4');
                        rect.setAttribute('ry', '4');

                        // CLICK HANDLER FOR CARD
                        rect.style.cursor = 'pointer';
                        rect.onclick = (e) => {
                            e.stopPropagation();
                            // Prevent if was dragging? (Simple check: if we moved mouse significantly... but this is 'click', usually safe)
                            showTaskCard(task);
                        };

                        // Status Color Logic
                        // let color = '#3b82f6'; // Default Blue('stroke-width', '2'); // This line was incomplete in the instruction, ignoring.
                        g.appendChild(rect);
                    } else {
                        // Standard Task Bar
                        // 1. Background (Light Blue)
                        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                        bgRect.setAttribute('x', x); bgRect.setAttribute('y', barY);
                        bgRect.setAttribute('width', Math.max(w, 5)); bgRect.setAttribute('height', barH);

                        // COLOR LOGIC: Check Company Color -> Default Blue
                        const companyColor = (task.contractor && State.companyColors[task.contractor]) ? State.companyColors[task.contractor] : '#dbeafe';
                        // If company color is set, use it for background? Or Progress?
                        // Usually Gantt background is pale, progress is dark.
                        // Let's make Background = Pale version of Company Color? 
                        // Or just use Company Color for Progress and standard pale blue for background?
                        // User Request: "sus colores". Implicitly distinctive.

                        // Revised: 
                        // Background = light gray/blue standard (or very light version of company color if we want to be fancy)
                        // Progress = Company Color.

                        // Simple: Background #dbeafe (default). 
                        // Progress uses Company Color if exists, else #3b82f6.

                        bgRect.setAttribute('fill', isHighlighted ? '#fecaca' : '#dbeafe'); // Red/Blue

                        bgRect.setAttribute('rx', barRadius);
                        g.appendChild(bgRect);

                        // 2. Progress (Dark Blue)
                        const pct = parseFloat(task.progress || 0) / 100;
                        if (pct > 0 && !isNaN(pct)) {
                            const progRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            progRect.setAttribute('x', x); progRect.setAttribute('y', barY);
                            const companyFill = (task.contractor && State.companyColors[task.contractor]) ? State.companyColors[task.contractor] : '#3b82f6';

                            progRect.setAttribute('width', Math.max(w * pct, 0));
                            progRect.setAttribute('height', barH);
                            progRect.setAttribute('fill', isHighlighted ? '#dc2626' : companyFill); progRect.setAttribute('rx', barRadius);
                            g.appendChild(progRect);
                        }

                        // 3. Comment Icon on Bar
                        if (task.comments && task.comments.length > 0) {
                            const iconText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            iconText.setAttribute('x', x + w + 5);
                            iconText.setAttribute('y', barY + 14); // Vertically centered approx
                            iconText.setAttribute('font-family', '"Font Awesome 6 Free", FontAwesome');
                            iconText.setAttribute('font-weight', '900');
                            iconText.setAttribute('font-size', '14');
                            iconText.setAttribute('fill', '#3b82f6');
                            iconText.textContent = '\uf086'; // fa-comment-dots
                            g.appendChild(iconText);
                        }

                        // CLICK HANDLER FOR STANDARD TASK
                        g.style.cursor = 'pointer';
                        g.onclick = (e) => {
                            e.stopPropagation();
                            showTaskCard(task);
                        };

                        // 4. EXTRA TIME BAR (Red Hatched)
                        const extDays = parseInt(task.extension_days) || 0;
                        if (extDays > 0) {
                            // Calculate width of extra days
                            // We need to project finish date + extDays
                            // Simple approximation: extDays * (pixels per day/one day width)
                            // Better: Project new date.

                            // Get end date object
                            const dEnd = new Date(task.end);
                            const dExt = new Date(dEnd);
                            dExt.setDate(dExt.getDate() + extDays);

                            const xStartExtra = x + w; // Starts exactly at end of main bar
                            const xEndExtra = timeToX(dExt.toISOString().split('T')[0]);
                            const wExtra = Math.max(xEndExtra - xStartExtra, 5); // Min 5px

                            const extRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                            extRect.setAttribute('x', xStartExtra);
                            extRect.setAttribute('y', barY + 2); // Slightly smaller? Or same. Let's do same height or slightly thinner to distinguish.
                            // User said "del lado derecho... refleje ese tiempo extra"
                            extRect.setAttribute('y', barY);
                            extRect.setAttribute('width', wExtra);
                            extRect.setAttribute('height', barH);

                            // Style: Red + Hatching
                            // We can use a pattern. check if 'hatchPattern' defined.
                            // If we added defs to body, we can reference simply url(#hatchPattern).
                            // But we also want a background color? "color rojo y con un ashurado distinto"
                            // Maybe fill with pattern, stroke red.

                            // Approach: White background, Red Hatch? Or Red background, Dark Hatch?
                            // "color rojo y con un ashurado" -> Visual: Red stripes.

                            // Let's rely on the pattern defined in HTML body.
                            // NOTE: Referencing external ID from shadow DOM or deep nesting usually works unless Shadow DOM.
                            extRect.setAttribute('fill', 'url(#hatchPattern)');
                            extRect.setAttribute('stroke', 'red');
                            extRect.setAttribute('stroke-width', '1');
                            extRect.setAttribute('opacity', '0.8');
                            // Add tooltip
                            const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
                            title.textContent = `Tiempo Extra: ${extDays} días`;
                            extRect.appendChild(title);

                            // Bind Click to Ext Rect too
                            extRect.onclick = (e) => {
                                e.stopPropagation();
                                showTaskCard(task);
                            };

                            g.appendChild(extRect);

                            // Optional: Label "+5d"
                            const diffText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            diffText.setAttribute('x', xStartExtra + wExtra + 4);
                            diffText.setAttribute('y', barY + 12);
                            diffText.setAttribute('font-size', '10');
                            diffText.setAttribute('fill', 'red');
                            diffText.setAttribute('font-weight', 'bold');
                            diffText.textContent = `+${extDays}d`;
                            g.appendChild(diffText);
                        }
                    }
                    barSvg.appendChild(g);
                }
                ganttTd.appendChild(barSvg);
                tr.appendChild(ganttTd);
                tbody.appendChild(tr);
            });
        }


        function getTotalStickyWidth() { return Config.columns.reduce((sum, col) => sum + col.width, 0); }

        function initTimeEngine() {
            if (State.tasks.length > 0) {
                // Dynamic Range Scan
                let minT = new Date(8640000000000000);
                let maxT = new Date(-8640000000000000);
                let hasDates = false;

                State.tasks.forEach(t => {
                    const s = new Date(t.start);
                    const e = new Date(t.end);
                    if (!isNaN(s.getTime())) {
                        if (s < minT) minT = s;
                        hasDates = true;
                    }
                    if (!isNaN(e.getTime())) {
                        if (e > maxT) maxT = e;
                        hasDates = true;
                    }
                });

                if (hasDates) {
                    // Buffer: 1 week before, 2 weeks after
                    minT.setDate(minT.getDate() - 7);
                    maxT.setDate(maxT.getDate() + 14);
                    State.startDate = minT;

                    // Calc dynamic Width
                    const diffMins = (maxT - minT) / 60000;
                    State.totalWidth = Math.max(2000, diffMins * State.pxPerMin);
                } else {
                    State.startDate = new Date();
                    State.startDate.setDate(State.startDate.getDate() - 7);
                    State.totalWidth = 3000;
                }
            } else {
                State.startDate = new Date();
                State.startDate.setDate(State.startDate.getDate() - 7);
                State.totalWidth = 3000;
            }
        }
        function calculateTotalWidth() { return State.totalWidth || 3000; }

        function timeToX(dateStr) {
            const d = new Date(dateStr);
            const diffMins = (d - State.startDate) / 60000;
            return diffMins * State.pxPerMin;
        }
        function initResize(e, col) {
            e.preventDefault();
            const startX = e.clientX;
            const startW = col.width;

            function onMove(me) {
                const diff = me.clientX - startX;
                col.width = Math.max(20, startW + diff);
                render(); // Re-render headers & rows
            }

            function onUp() {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            }

            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        }

        // --- CONTEXT MENU LOGIC ---
        let contextMenuTarget = null; // { task, type: 'row'|'bar' }

        document.addEventListener('contextmenu', (e) => {
            // Check if inside Grid Row or Gantt Bar
            const row = e.target.closest('tr');
            const bar = e.target.closest('.gantt-bar-group');

            if (!row && !bar) {
                hideContextMenu();
                return;
            }

            e.preventDefault();

            let task = null;
            if (row) {
                const idx = row.getAttribute('data-row-index');
                if (idx) task = State.tasks[parseInt(idx)];
            } else if (bar) {
                const id = bar.getAttribute('data-id');
                task = State.tasks.find(t => t.id === id);
            }

            if (task) {
                contextMenuTarget = task;
                State.contextTask = task; // Sync with State
                showContextMenu(e.clientX, e.clientY);
            }
        });

        document.addEventListener('click', (e) => {
            if (e.target.closest('#context-menu')) return;
            hideContextMenu();
        });

        function showContextMenu(x, y) {
            let menu = document.getElementById('context-menu');
            if (!menu) {
                menu = document.createElement('div');
                menu.id = 'context-menu';
                document.body.appendChild(menu);
            }

            menu.innerHTML = `
                <div class="item" onclick="triggerAssignCompany()"><i class="fas fa-building mr-2"></i> Asignar Empresa</div>
                <div class="item" onclick="triggerAddComment()"><i class="fas fa-comment mr-2"></i> Agregar Comentario</div>
                <div class="separator"></div>
                <div class="item" onclick="State.activeCell={taskId:contextMenuTarget.id, colId:'duration'}; enterEditMode(); hideContextMenu();"><i class="fas fa-edit mr-2"></i> Editar Duración</div>
                <div class="separator"></div>
                <div class="item" onclick="triggerAddExtraTime()"><i class="fas fa-clock mr-2 text-red-500"></i> Agregar Tiempo Extra</div>
                <div class="separator"></div>
                <div class="item" onclick="insertTask('above')"><i class="fas fa-arrow-up mr-2 text-green-600"></i> Insertar Tarea Arriba</div>
                <div class="item" onclick="insertTask('below')"><i class="fas fa-arrow-down mr-2 text-green-600"></i> Insertar Tarea Abajo</div>
            `;

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.style.display = 'block';
        }

        function hideContextMenu() {
            const menu = document.getElementById('context-menu');
            if (menu) menu.style.display = 'none';
        }

        // --- ADD TASK LOGIC ---
        window.addTask = function () {
            const qtyStr = prompt("¿Cuántas tareas deseas agregar?", "1");
            if (!qtyStr) return;
            const qty = parseInt(qtyStr);
            if (isNaN(qty) || qty <= 0) return;

            const newTasks = [];
            // Insert at bottom by default
            const maxOrder = State.tasks.length > 0 ? Math.max(...State.tasks.map(t => t.orderIndex || 0)) : 0;

            for (let i = 1; i <= qty; i++) {
                newTasks.push({
                    id: 'new_' + Date.now() + '_' + i + '_' + Math.random().toString(36).substr(2, 5),
                    name: 'Nueva Tarea ' + i,
                    start: new Date().toISOString().split('T')[0],
                    end: new Date().toISOString().split('T')[0],
                    duration: 1,
                    progress: 0,
                    level: 0,
                    orderIndex: maxOrder + i,
                    contractor: 'Sin Asignar',
                    style: {},
                    cellStyles: {}
                });
            }

            State.tasks.push(...newTasks);
            HierarchyEngine.recalculate(State.tasks);
            render();
            triggerAutoSave(newTasks[0].id); // Trigger save

            // Scroll to bottom
            setTimeout(() => {
                const table = document.getElementById('master-scroll');
                table.scrollTop = table.scrollHeight;
                // Init time engine again to expand if needed?
                initTimeEngine();
                render(); // Re-render with new width
            }, 100);
        };

        window.insertTask = function (direction) { // 'above' or 'below'
            hideContextMenu();
            if (!contextMenuTarget) return;

            const targetTask = contextMenuTarget;
            const qtyStr = prompt("¿Cuántas tareas deseas agregar?", "1");
            if (!qtyStr) return;
            const qty = parseInt(qtyStr);
            if (isNaN(qty) || qty <= 0) return;

            // Determine Start Order Index
            let insertOrder = targetTask.orderIndex;
            if (direction === 'below') insertOrder += 1;

            // Shift existing orders down to make room
            State.tasks.forEach(t => {
                if (t.orderIndex >= insertOrder) {
                    t.orderIndex += qty;
                }
            });

            const newTasks = [];
            for (let i = 0; i < qty; i++) {
                newTasks.push({
                    id: 'new_ctx_' + Date.now() + '_' + i + '_' + Math.random().toString(36).substr(2, 5),
                    name: 'Tarea Insertada ' + (i + 1),
                    start: targetTask.start, // Copy date from neighbor
                    end: targetTask.end,
                    duration: 1,
                    progress: 0,
                    level: targetTask.level, // Copy indentation
                    orderIndex: insertOrder + i,
                    contractor: targetTask.contractor || 'Sin Asignar',
                    parentId: targetTask.parentId,
                    style: {},
                    cellStyles: {}
                });
            }

            State.tasks.push(...newTasks);
            State.tasks.sort((a, b) => a.orderIndex - b.orderIndex);

            HierarchyEngine.recalculate(State.tasks);
            render();
            triggerAutoSave(newTasks[0].id);
        };

        // --- ACTIONS ---
        function triggerAssignCompany() {
            hideContextMenu();
            if (!contextMenuTarget) return;
            // Use existing openCompanyModal but pre-select? 
            // Or just open generic? User said "click derecho... aparezca la opcion asignar empresa"
            // Currently openCompanyModal manages 'Active Companies' globally usually? 
            // Or does it assign to task? 
            // Looking at code... openCompanyModal seems to manage a global list of companies.
            // But we probably want to assign the 'contractor' field of the task.

            // Quick Fix: Open prompt or specific modal for Task Contractor
            const companies = Object.keys(State.companyColors);
            // Simple Prompt for now, or reuse modal if adaptable.
            // We can update the 'contractor' field.

            // Let's reuse the Company Modal but maybe highlight that we are assigning to THIS task?
            // Actually, the main Company Modal (from toolbar) manages "Available Companies".
            // Assigning to a task usually means setting task.contractor = "LOBOS".

            // Let's create a mini selector or use prompt
            // const comp = prompt("Asignar Empresa (existente o nueva):", contextMenuTarget.contractor || "");
            // if(comp !== null) {
            //    updateTaskValue(contextMenuTarget, 'contractor', comp);
            // }

            // Better: Show a small dialog with buttons of existing companies
            openTaskCompanyPicker(contextMenuTarget);
        }

        function openTaskCompanyPicker(task) {
            const existing = Object.keys(State.companyColors);
            const dialog = document.createElement('dialog');
            dialog.className = "bg-white p-4 rounded shadow-lg border border-gray-200";
            dialog.style.position = "fixed";
            dialog.style.top = "50%";
            dialog.style.left = "50%";
            dialog.style.transform = "translate(-50%, -50%)";

            let html = `<h3 class="font-bold mb-2">Asignar Empresa</h3><div class="flex flex-col gap-2">`;
            existing.forEach(c => {
                html += `<button class="p-2 border rounded hover:bg-gray-100 text-left" onclick="selectComp('${c}')">
                             <span class="w-3 h-3 inline-block rounded-full px-2" style="background:${State.companyColors[c]}"></span> ${c}
                          </button>`;
            });
            html += `<button class="p-2 border rounded hover:bg-gray-100 text-left text-blue-600" onclick="const n=prompt('Nueva Empresa'); if(n) selectComp(n);">+ Nueva</button>`;
            html += `</div><button class="mt-4 text-xs text-gray-500" onclick="this.closest('dialog').remove()">Cancelar</button>`;

            dialog.innerHTML = html;
            document.body.appendChild(dialog);
            dialog.showModal();

            window.selectComp = (c) => {
                // Determine targets: If selection exists and context target is part of it, use selection.
                // Otherwise use single target.
                let targets = [task];
                const uniqueTaskIds = new Set();

                if (State.selectedCells.size > 0) {
                    State.selectedCells.forEach(k => uniqueTaskIds.add(k.split(':')[0]));
                }

                if (uniqueTaskIds.has(task.id)) {
                    // Apply to entire selection
                    targets = Array.from(uniqueTaskIds).map(id => State.tasks.find(t => t.id === id)).filter(Boolean);
                }

                targets.forEach(t => updateTaskValue(t, 'contractor', c));

                // Ensure color exists
                if (!State.companyColors[c]) {
                    // Assign random color
                    State.companyColors[c] = '#' + Math.floor(Math.random() * 16777215).toString(16);
                }
                dialog.close();
                dialog.remove();
            }
        }

        function triggerAddComment() {
            hideContextMenu();
            if (!contextMenuTarget) return;
            openCommentsModal(contextMenuTarget);
        }

        // --- COMMENTS MODAL ---
        function openCommentsModal(task) {
            let modal = document.getElementById('comments-modal');
            if (modal) modal.remove();

            modal = document.createElement('div');
            modal.id = 'comments-modal';
            modal.className = "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[2000]";

            const comments = task.comments || [];

            modal.innerHTML = `
                 <div class="bg-white w-[500px] h-[600px] rounded-lg shadow-xl flex flex-col">
                     <div class="flex justify-between items-center p-4 border-b">
                         <h3 class="font-bold text-lg">Comentarios: ${task.name}</h3>
                         <button onclick="document.getElementById('comments-modal').remove()" class="text-gray-500 hover:text-black">&times;</button>
                     </div>
                     <div class="flex-1 overflow-y-auto p-4" id="comments-list">
                         ${renderCommentsList(comments)}
                     </div>
                     <div class="p-4 border-t bg-gray-50">
                         <textarea id="comment-input" class="w-full border rounded p-2 text-sm mb-2" rows="3" placeholder="Escribe un comentario..."></textarea>
                         <div class="flex justify-between items-center">
                             <input type="file" id="comment-file" class="text-xs" accept=".pdf,.png,.jpg,.jpeg">
                             <button onclick="submitComment('${task.id}')" class="bg-blue-600 text-white px-4 py-1 rounded text-sm">Enviar</button>
                         </div>
                     </div>
                 </div>
             `;
            document.body.appendChild(modal);

            // Scroll to bottom
            const list = document.getElementById('comments-list');
            list.scrollTop = list.scrollHeight;
        }

        function renderCommentsList(comments) {
            if (!comments || comments.length === 0) return '<div class="text-gray-400 text-center mt-10">No hay comentarios aún.</div>';

            return comments.map(c => `
                <div class="comment-bubble ${c.userId === '{{ user.id }}' ? 'me' : ''}">
                    <div class="comment-header">
                        <img src="${c.userAvatar || 'https://ui-avatars.com/api/?name=' + (c.userName || 'User')}" class="comment-avatar">
                        <div>
                            <span class="font-bold text-xs">${c.userName || 'Usuario'}</span>
                            <span class="text-xs text-gray-500 ml-2">${new Date(c.timestamp).toLocaleString()}</span>
                        </div>
                    </div>
                    <div class="text-sm text-gray-800">${c.text}</div>
                    ${c.attachments && c.attachments.length > 0 ? `
                        <div class="mt-2">
                             ${c.attachments.map(a => `
                                 <div class="attachment-preview" onclick="openAttachment('${a.url}')" ondblclick="window.open('${a.url}', '_blank')">
                                     <i class="fas fa-paperclip text-gray-500"></i> <span class="text-xs">${a.name}</span>
                                 </div>
                             `).join('')}
                        </div>
                    ` : ''}
                </div>
            `).join('');
        }

        window.submitComment = async (taskId) => {
            const input = document.getElementById('comment-input');
            const fileInput = document.getElementById('comment-file');
            const text = input.value.trim();
            const file = fileInput.files[0];

            if (!text && !file) return;

            const task = State.tasks.find(t => t.id === taskId);
            if (!task) return;

            if (!task.comments) task.comments = [];

            // Upload File first if exists (mock upload for now or real if endpoint exists)
            // We have /api/projects/{id}/schedule, but not general upload.
            // Requirement said "adjuntar pdf, png". I should assume we store as DataURI or implement upload.
            // Using DataURI is easiest for "Visual" requirement without heavy backend change, but bad for performance.
            // Better: use a mock URL or just store name if waiting for backend implementation.
            // Actually, I can use the same file input to read as DataURL to show preview immediately.

            let attachments = [];
            if (file) {
                // Read as DataURL for demo persistence in JSON
                const reader = new FileReader();
                reader.onload = (e) => {
                    attachments.push({
                        name: file.name,
                        type: file.type,
                        url: e.target.result // Storing base64 in JSON (Heavy but self-contained)
                    });
                    finishSubmit();
                };
                reader.readAsDataURL(file);
            } else {
                finishSubmit();
            }

            function finishSubmit() {
                const newComment = {
                    id: Date.now().toString(),
                    userId: '{{ user.id }}' || 'guest', // Jinja inject
                    userName: '{{ user_name }}' || 'Invitado',
                    userAvatar: null, // UI Avatars fallback
                    text: text,
                    timestamp: new Date().toISOString(),
                    attachments: attachments
                };

                task.comments.push(newComment);
                triggerAutoSave(task.id);

                // Refresh Modal
                const list = document.getElementById('comments-list');
                list.innerHTML = renderCommentsList(task.comments);
                list.scrollTop = list.scrollHeight;
                input.value = '';
                fileInput.value = '';
            }
        };

        window.openAttachment = (url) => {
            // Preview Modal
            let p = document.createElement('div');
            p.className = "fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-[2100]";
            p.onclick = () => p.remove();

            if (url.startsWith('data:image')) {
                p.innerHTML = `<img src="${url}" class="max-w-[90%] max-h-[90%] rounded shadow-lg">`;
            } else {
                p.innerHTML = `<div class="bg-white p-8 rounded">Is PDF/Doc. <a href="${url}" target="_blank" class="text-blue-600 underline">Click to Open</a></div>`;
            }
            document.body.appendChild(p);
        };

        // --- RENDER HEADER UPDATE ---
        // --- GLOBAL EXPORTS ---
        window.triggerAssignCompany = triggerAssignCompany;
        window.triggerAddComment = triggerAddComment;
        window.enterEditMode = enterEditMode;
        window.triggerAddExtraTime = triggerAddExtraTime;
        window.hideContextMenu = hideContextMenu;

        window.AO = {
            Gantt: {
                zoomIn: () => {
                    if (State.zoom === 'MONTH') State.zoom = 'WEEK';
                    else if (State.zoom === 'WEEK') State.zoom = 'DAY';
                    const lbl = document.getElementById('zoom-label');
                    if (lbl) lbl.innerText = State.zoom;
                    render();
                },
                zoomOut: () => {
                    if (State.zoom === 'DAY') State.zoom = 'WEEK';
                    else if (State.zoom === 'WEEK') State.zoom = 'MONTH';
                    const lbl = document.getElementById('zoom-label');
                    if (lbl) lbl.innerText = State.zoom;
                    render();
                }
            }
        };

        // Double Click to Edit
        document.addEventListener('dblclick', (e) => {
            if (!e.target.closest('#main-table')) return;
            enterEditMode();
        });

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        function triggerAddExtraTime() {
            console.log("triggerAddExtraTime called");
            hideContextMenu();
            const task = State.contextTask;
            console.log("Context task:", task);
            if (!task) {
                alert("Error: No task selected");
                return;
            }

            const current = parseInt(task.extension_days) || 0;
            const input = prompt("Ingrese días de tiempo extra (retraso planificado):", current);

            if (input !== null) {
                const days = parseInt(input);
                if (!isNaN(days) && days >= 0) {
                    task.extension_days = days;
                    if (typeof saveDirtyTasks === 'function') saveDirtyTasks();
                    render();
                } else {
                    alert("Por favor ingrese un número válido.");
                }
            }
        }

        // --- TAKS DETAILS CARD LOGIC ---
        // --- TASK DETAILS CARD LOGIC ---
        window.showTaskCard = function (task) {
            // Close existing
            const ex = document.getElementById('task-card-modal');
            if (ex) ex.remove();

            const modal = document.createElement('div');
            modal.id = 'task-card-modal';
            modal.className = 'task-card-overlay';

            // Calculate Duration if undefined
            let dispDuration = task.duration;
            if (!dispDuration || dispDuration === 'undefined') {
                const s = new Date(task.start);
                const e = new Date(task.end);
                if (!isNaN(s) && !isNaN(e)) {
                    dispDuration = Math.round((e - s) / (1000 * 60 * 60 * 24));
                } else {
                    dispDuration = 0;
                }
            }

            // Contractor Options
            const companyOptions = Object.keys(State.companyColors).map(c =>
                `<option value="${c}" ${task.contractor === c ? 'selected' : ''}>${c}</option>`
            ).join('');
            const addNewOption = `<option value="__NEW__">+ Nueva...</option>`;

            // Helper to render chart (same as before)
            const history = task.history || [];
            const tStart = new Date(task.start).getTime();
            const tEnd = new Date(task.end).getTime();
            const totalDuration = tEnd - tStart;
            const sortedHist = [...history].sort((a, b) => new Date(a.date) - new Date(b.date));
            let points = [];
            points.push([0, 100]);
            sortedHist.forEach(h => {
                const d = new Date(h.date).getTime();
                let x = 0;
                if (totalDuration > 0) {
                    x = Math.max(0, Math.min(100, ((d - tStart) / totalDuration) * 100));
                }
                const y = 100 - parseFloat(h.progress);
                points.push([x, y]);
            });
            const currentP = parseFloat(task.progress || 0);
            if (sortedHist.length === 0 || sortedHist[sortedHist.length - 1].progress != currentP) {
                const now = new Date().getTime();
                let xNow = 100;
                if (totalDuration > 0 && now < tEnd) {
                    xNow = Math.max(0, Math.min(100, ((now - tStart) / totalDuration) * 100));
                }
                points.push([xNow, 100 - currentP]);
            }
            const polylinePoints = points.map(p => `${p[0]},${p[1]}`).join(' ');

            modal.innerHTML = `
                 <div class="task-card">
                     <div class="card-header">
                         <div class="w-full mr-4">
                             <input type="text" id="card-name" value="${task.name}" class="text-xl font-bold text-gray-800 w-full border-b border-transparent hover:border-gray-300 focus:border-blue-500 outline-none bg-transparent" placeholder="Nombre de la tarea">
                             <span class="text-xs text-blue-600 font-mono select-all">${task.id}</span>
                         </div>
                         <button onclick="document.getElementById('task-card-modal').remove()" class="text-gray-400 hover:text-red-500 text-2xl">&times;</button>
                     </div>
                     <div class="card-body">
                         <div class="card-row">
                             <div class="flex-1 mr-2">
                                 <div class="card-label">Inicio</div>
                                 <input type="date" id="card-start" value="${task.start}" class="w-full border rounded px-1 py-0.5 text-sm" onchange="recalcCardDuration()">
                             </div>
                             <div class="flex-1 ml-2">
                                 <div class="card-label">Fin</div>
                                 <input type="date" id="card-end" value="${task.end}" class="w-full border rounded px-1 py-0.5 text-sm" onchange="recalcCardDuration()">
                             </div>
                         </div>
                         <div class="card-row">
                             <div class="flex-1 mr-2">
                                 <div class="card-label">Duración (Días)</div>
                                 <input type="number" id="card-duration" value="${dispDuration}" class="w-full border rounded px-1 py-0.5 text-sm bg-gray-50" readonly>
                             </div>
                             <div class="flex-1 ml-2">
                                 <div class="card-label">Empresa</div>
                                 <div class="flex items-center">
                                    <span id="card-comp-color" class="w-3 h-3 rounded-full mr-2" style="background:${State.companyColors[task.contractor] || '#ccc'}"></span>
                                    <select id="card-contractor" class="w-full border rounded px-1 py-0.5 text-sm" onchange="handleCardCompChange(this)">
                                        <option value="">-- Sin Asignar --</option>
                                        ${companyOptions}
                                        ${addNewOption}
                                    </select>
                                 </div>
                             </div>
                         </div>
                         <div class="card-row">
                             <div class="flex-1 mr-2">
                                 <div class="card-label">Avance (%)</div>
                                 <input type="number" id="card-progress" value="${task.progress || 0}" min="0" max="100" class="w-full border rounded px-1 py-0.5 text-sm font-bold text-blue-600">
                             </div>
                             <div class="flex-1 ml-2">
                                 <div class="card-label">Tiempo Extra (Días)</div>
                                 <input type="number" id="card-extension" value="${task.extension_days || 0}" min="0" class="w-full border rounded px-1 py-0.5 text-sm font-bold text-red-600">
                             </div>
                         </div>
                         
                         <!-- Chart Section (Read Only) -->
                         <div class="mb-4">
                             <div class="card-label">Métrica de Cumplimiento (% vs Tiempo)</div>
                             <div class="metric-chart">
                                 <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none">
                                      <line x1="0" y1="25" x2="100" y2="25" stroke="#eee" stroke-width="0.5" />
                                      <line x1="0" y1="50" x2="100" y2="50" stroke="#eee" stroke-width="0.5" />
                                      <line x1="0" y1="75" x2="100" y2="75" stroke="#eee" stroke-width="0.5" />
                                      <polyline points="${polylinePoints}" fill="none" stroke="#3b82f6" stroke-width="2" />
                                      ${points.map(p => `<circle cx="${p[0]}" cy="${p[1]}" r="1.5" fill="#2563eb" />`).join('')}
                                 </svg>
                             </div>
                         </div>

                         <div>
                             <div class="card-label">Comentarios Recientes</div>
                             <button class="mt-1 text-blue-600 text-xs hover:underline float-right" onclick="openCommentsModal(State.tasks.find(t=>t.id=='${task.id}'))">Gestionar Comentarios</button>
                             <div class="bg-gray-50 rounded p-2 text-sm max-h-24 overflow-y-auto clear-both border">
                                 ${(task.comments && task.comments.length > 0)
                    ? task.comments.slice(-3).map(c => `
                                         <div class="mb-1 border-b last:border-0 pb-1">
                                             <span class="font-bold text-xs">${c.userName}:</span> <span class="text-gray-700 text-xs">${c.text}</span>
                                         </div>
                                       `).join('')
                    : '<span class="text-gray-400 italic text-xs">No hay comentarios</span>'
                }
                             </div>
                         </div>
                         
                         <!-- Actions -->
                         <div class="mt-4 flex justify-end gap-2 border-t pt-2">
                             <button class="px-3 py-1 text-gray-600 text-sm hover:bg-gray-100 rounded" onclick="document.getElementById('task-card-modal').remove()">Cancelar</button>
                             <button class="px-3 py-1 bg-blue-600 text-white text-sm rounded shadow hover:bg-blue-700 font-bold" onclick="saveTaskFromCard('${task.id}')">Guardar Cambios</button>
                         </div>
                     </div>
                 </div>
             `;
            document.body.appendChild(modal);
        };

        window.recalcCardDuration = function () {
            const sStr = document.getElementById('card-start').value;
            const eStr = document.getElementById('card-end').value;
            if (sStr && eStr) {
                const s = new Date(sStr);
                const e = new Date(eStr);
                const diffTime = Math.abs(e - s);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                document.getElementById('card-duration').value = diffDays >= 0 ? diffDays : 0;
            }
        };

        window.handleCardCompChange = function (select) {
            const val = select.value;
            if (val === '__NEW__') {
                const n = prompt("Nombre de la nueva empresa:");
                if (n) {
                    if (!State.companyColors[n]) {
                        State.companyColors[n] = '#' + Math.floor(Math.random() * 16777215).toString(16);
                    }
                    // Add option
                    const opt = document.createElement('option');
                    opt.value = n;
                    opt.text = n;
                    opt.selected = true;
                    // Insert before last
                    select.add(opt, select.options[select.length - 1]);
                    select.value = n;
                } else {
                    select.value = "";
                }
            }
            const c = select.value;
            const color = State.companyColors[c] || '#ccc';
            document.getElementById('card-comp-color').style.background = color;
        };

        window.saveTaskFromCard = function (taskId) {
            const task = State.tasks.find(t => t.id === taskId);
            if (!task) return;

            task.name = document.getElementById('card-name').value;
            task.start = document.getElementById('card-start').value;
            task.end = document.getElementById('card-end').value;
            // Recalc duration in object just in case
            task.duration = parseInt(document.getElementById('card-duration').value) || 0;

            task.contractor = document.getElementById('card-contractor').value;
            task.progress = parseInt(document.getElementById('card-progress').value) || 0;
            task.extension_days = parseInt(document.getElementById('card-extension').value) || 0;

            // Logic: If dates changed, we might need to recalc parents? 
            // HierarchyEngine.recalculate(State.tasks); // If available

            triggerAutoSave(taskId);
            render();
            document.getElementById('task-card-modal').remove();
        };
    </script>
</body>

</html>