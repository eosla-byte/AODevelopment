<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>AO Labs | Cloud Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: #0f172a;
            color: #e2e8f0;
        }

        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
        }

        .tree-item {
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tree-item:hover {
            background: rgba(59, 130, 246, 0.2);
        }

        .tree-item.selected {
            background: rgba(59, 130, 246, 0.5);
            border-left: 3px solid #60a5fa;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1e293b;
        }

        ::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }

        .upload-zone {
            border: 2px dashed #475569;
            transition: all 0.3s ease;
        }

        .upload-zone.dragover {
            border-color: #60a5fa;
            background: rgba(59, 130, 246, 0.1);
        }

        /* Context Menu */
        #contextMenu {
            display: none;
            position: absolute;
            z-index: 1000;
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            min-width: 150px;
        }

        #contextMenu div {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            color: #e2e8f0;
        }

        #contextMenu div:hover {
            background: #3b82f6;
            color: white;
        }

        .tree-item.drag-over {
            background: rgba(59, 130, 246, 0.4);
            border: 2px dashed #60a5fa;
        }

        /* Context Menu */
        #contextMenu {
            display: none;
            position: absolute;
            z-index: 1000;
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 6px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            min-width: 150px;
        }

        #contextMenu div {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            color: #e2e8f0;
        }

        #contextMenu div:hover {
            background: #3b82f6;
            color: white;
        }

        .tree-item.drag-over {
            background: rgba(59, 130, 246, 0.4);
            border: 2px dashed #60a5fa;
        }
    </style>
</head>

<body class="h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header
        class="h-16 border-b border-slate-700 flex items-center justify-between px-6 bg-slate-900/80 backdrop-blur-md z-10">
        <div class="flex items-center gap-3">
            <div
                class="w-8 h-8 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center font-bold">
                L</div>
            <h1 class="text-xl font-bold tracking-tight">AO Labs <span class="text-slate-500 font-light mx-2">/</span>
                Cloud Manager</h1>
        </div>
        <a href="/dashboard" class="text-sm text-slate-400 hover:text-white transition">Exit to Dashboard</a>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex overflow-hidden">

        <!-- Left: Local Upload / Actions -->
        <aside class="w-1/3 p-6 border-r border-slate-700 flex flex-col gap-6 bg-slate-900/50">

            <div class="glass-panel p-6 flex-1 flex flex-col">
                <h2 class="text-lg font-semibold mb-4 text-purple-400">üì§ Local Upload</h2>

                <div id="dropZone"
                    class="upload-zone flex-1 rounded-xl flex flex-col items-center justify-center p-8 text-center cursor-pointer relative">
                    <input type="file" id="fileInput" class="hidden" multiple webkitdirectory />
                    <svg class="w-16 h-16 text-slate-500 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12">
                        </path>
                    </svg>
                    <p class="text-slate-300 font-medium">Drag Folders or Files Here</p>
                    <p class="text-slate-500 text-sm mt-2">Supports folder structures</p>

                    <button onclick="document.getElementById('fileInput').click()"
                        class="mt-6 px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-sm transition">Browse
                        Computer</button>
                </div>

                <div id="uploadStatus" class="hidden mt-4 flex flex-col gap-2">
                    <div class="flex justify-between text-xs text-slate-400 mb-1">
                        <span>Uploading...</span>
                        <div class="flex gap-2">
                            <span id="uploadPercent">0%</span>
                            <button onclick="document.getElementById('uploadStatus').classList.add('hidden')"
                                class="hover:text-white px-1"><i class="fas fa-times"></i></button>
                        </div>
                    </div>
                    <div class="h-2 bg-slate-700 rounded-full overflow-hidden">
                        <div id="progressBar" class="h-full bg-purple-500 w-0 transition-all duration-300"></div>
                    </div>
                    <div id="uploadLog"
                        class="h-32 bg-[#101010] border border-[#333] rounded p-2 overflow-y-auto text-[10px] font-mono text-gray-400 mt-2">
                        <!-- Logs -->
                    </div>
                </div>
            </div>

            <div class="glass-panel p-4">
                <h3 class="text-sm font-semibold text-slate-400 mb-2">ACTIONS on SELECTION</h3>
                <div class="grid grid-cols-2 gap-2">
                    <button id="btnCopy" onclick="menuAction('copy')"
                        class="p-3 bg-slate-800 hover:bg-slate-700 rounded text-sm text-left flex items-center gap-2"
                        disabled>
                        <span>üìã</span> Copy Folder
                    </button>
                    <button id="btnPaste" onclick="menuAction('paste')"
                        class="p-3 bg-slate-800 hover:bg-slate-700 rounded text-sm text-left flex items-center gap-2 opacity-50 cursor-not-allowed"
                        disabled>
                        <span>üì•</span> Paste Here
                    </button>
                    <button id="btnNewFolder" onclick="menuAction('new-folder')"
                        class="p-3 bg-slate-800 hover:bg-slate-700 rounded text-sm text-left flex items-center gap-2"
                        disabled>
                        <span>üìÅ</span> New Folder
                    </button>
                </div>
            </div>

            <!-- Context Menu HTML -->
            <div id="contextMenu">
                <div onclick="menuAction('copy')">üìã Copy</div>
                <div onclick="menuAction('paste')" id="ctxPaste">üì• Paste</div>
                <div class="border-t border-slate-600 my-1"></div>
                <div onclick="menuAction('new-folder')">üìÅ New Folder</div>
                <div onclick="menuAction('delete')">üóëÔ∏è Delete</div>
            </div>
        </aside>

        <!-- Right: Cloud Browser -->
        <section class="flex-1 p-6 flex flex-col min-w-0">
            <div class="glass-panel w-full h-full flex flex-col overflow-hidden">
                <div class="p-4 border-b border-slate-700 bg-slate-800/50 flex justify-between items-center">
                    <h2 class="text-lg font-semibold text-blue-400">‚òÅÔ∏è Autodesk Docs Browser</h2>
                    <button onclick="loadHubs()"
                        class="text-xs bg-slate-700 px-2 py-1 rounded hover:bg-slate-600">Refresh</button>
                </div>

                <div id="treeView" class="flex-1 overflow-y-auto p-4 space-y-1">
                    <!-- Tree Content -->
                    <div class="flex items-center justify-center h-64 text-slate-500 animate-pulse">Loading Cloud
                        Data...</div>
                </div>

                <div class="p-2 border-t border-slate-700 text-xs text-slate-500 flex gap-4 bg-slate-900/50">
                    <span id="statusText">Ready</span>
                    <span id="selectionText" class="text-blue-400 truncate flex-1"></span>
                </div>
            </div>
        </section>

    </main>

    <!-- Scripts -->
    <script>
        // State
        let currentHubId = null;
        let currentProjectId = null;
        let selectedNode = null; // { id, type, name, parentId }
        let clipboard = null; // { id, name, type }

        const API = '/api/labs/acc';

        // Load Initial
        document.addEventListener('DOMContentLoaded', loadHubs);

        async function loadHubs() {
            setLoading('Loading Hubs...');
            const tree = document.getElementById('treeView');
            tree.innerHTML = '';

            try {
                const res = await fetch(`${API}/hubs`);
                const hubs = await res.json();

                hubs.forEach(h => {
                    tree.appendChild(createNodeEl(h.id, h.attributes.name, 'hub', null));
                });

                setStatus('Select a Hub to connect');
            } catch (e) {
                tree.innerHTML = `<div class="p-4 text-red-400">Error loading hubs. Check console.</div>`;
                console.error(e);
            }
        }

        // Logic to build tree
        function setLoading(msg) {
            const tree = document.getElementById('treeView');
            tree.innerHTML = `<div class="flex items-center justify-center h-64 text-slate-500 animate-pulse">${msg}</div>`;
        }

        function createNodeEl(id, name, type, parentId) {
            const container = document.createElement('div');
            container.className = 'pl-4 border-l border-slate-700 ml-2 mt-1';
            if (type === 'hub') container.className = ''; // Root no indent

            const row = document.createElement('div');
            row.className = 'tree-item group';
            row.dataset.id = id;
            row.dataset.type = type;
            row.dataset.loaded = 'false';

            // Icons
            let icon = 'üè¢';
            if (type === 'project') icon = 'üèóÔ∏è';
            if (type === 'folder') icon = 'üìÅ';
            if (type === 'item') icon = 'üìÑ';

            row.innerHTML = `
                <span class="opacity-50 group-hover:opacity-100 transition text-xs select-none">‚ñ∂</span>
                <span class="text-lg">${icon}</span>
                <span class="truncate text-sm font-medium">${name}</span>
            `;

            // Click Handler
            row.onclick = (e) => {
                e.stopPropagation();
                selectNode(row, id, name, type, parentId);
                toggleExpand(row, container, id, type);
            };

            const wrapper = document.createElement('div');
            wrapper.appendChild(row);

            // Container for children
            const childrenDiv = document.createElement('div');
            childrenDiv.className = 'hidden pl-2';
            wrapper.appendChild(childrenDiv);

            row.childrenDiv = childrenDiv; // Ref

            // Add Drag & Drop + Context Menu
            addDnD(row, id, type);

            return wrapper;
        }

        async function toggleExpand(row, container, id, type) {
            const childrenDiv = row.childrenDiv;
            const arrow = row.querySelector('span:first-child');

            if (!childrenDiv.classList.contains('hidden')) {
                // Collapse
                childrenDiv.classList.add('hidden');
                arrow.innerText = '‚ñ∂';
                return;
            }

            // Expand
            childrenDiv.classList.remove('hidden');
            arrow.innerText = '‚ñº';

            if (row.dataset.loaded === 'true') return; // Already loaded

            // Fetch Children
            row.classList.add('animate-pulse');

            try {
                if (type === 'hub') {
                    // Fetch Projects
                    currentHubId = id;
                    const res = await fetch(`${API}/hubs/${id}/projects`);
                    const data = await res.json();
                    data.forEach(p => childrenDiv.appendChild(createNodeEl(p.id, p.attributes.name, 'project', id)));
                }
                else if (type === 'project') {
                    // Fetch Top Folders
                    currentProjectId = id;
                    const res = await fetch(`${API}/projects/${id}/top-folders?hub_id=${currentHubId}`);
                    const data = await res.json();
                    data.forEach(f => childrenDiv.appendChild(createNodeEl(f.id, f.attributes.name, 'folder', id)));
                }
                else if (type === 'folder') {
                    // Fetch Contents
                    const res = await fetch(`${API}/projects/${currentProjectId}/folders/${id}/contents`);
                    const data = await res.json();

                    data.folders.forEach(f => childrenDiv.appendChild(createNodeEl(f.id, f.attributes.displayName || f.attributes.name, 'folder', id)));

                    // Optional: Show files? 
                    // data.items.forEach(i => childrenDiv.appendChild(createNodeEl(i.id, i.attributes.displayName, 'item', id)));
                }

                row.dataset.loaded = 'true';
            } catch (e) {
                console.error(e);
                setStatus('Error loading children');
            } finally {
                row.classList.remove('animate-pulse');
            }
        }

        function selectNode(row, id, name, type, parentId) {
            // UI
            document.querySelectorAll('.tree-item').forEach(el => el.classList.remove('selected', 'bg-blue-900'));
            row.classList.add('selected');

            selectedNode = { id, name, type, parentId };

            document.getElementById('selectionText').innerText = `Selected: ${name} (${type})`;

            // Update Buttons
            const canPaste = clipboard && type === 'folder';
            document.getElementById('btnPaste').disabled = !canPaste;
            document.getElementById('btnPaste').className = `p-3 bg-slate-800 rounded text-sm text-left flex items-center gap-2 ${canPaste ? 'hover:bg-blue-600 cursor-pointer' : 'opacity-50 cursor-not-allowed'}`;

            document.getElementById('btnCopy').disabled = (type !== 'folder' && type !== 'item');
            document.getElementById('btnNewFolder').disabled = (type !== 'folder' && type !== 'project'); // Usually create in Project root or folder
        }

        function logStatus(msg, type = 'info') {
            const logDiv = document.getElementById('uploadLog');
            if (!logDiv) return;

            const line = document.createElement('div');
            line.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            if (type === 'error') line.style.color = '#ff4d4d';
            if (type === 'success') line.style.color = '#4ade80';
            logDiv.appendChild(line);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // --- Context Menu Logic ---
        const contextMenu = document.getElementById('contextMenu');
        document.addEventListener('click', () => contextMenu.style.display = 'none');

        function setStatus(msg) {
            // prompt for status?
            // document.getElementById('statusText').innerText = msg;
        }

        // --- Context Menu Logic ---

        // contextMenu declared above at line 401

        function showContextMenu(e, node) {
            e.preventDefault();
            selectNode(node.row, node.id, node.name, node.type, node.parentId);

            contextMenu.style.left = `${e.pageX}px`;
            contextMenu.style.top = `${e.pageY}px`;
            contextMenu.style.display = 'block';

            // Conditional Logic
            const pasteBtn = document.getElementById('ctxPaste');
            pasteBtn.style.display = (clipboard && node.type === 'folder') ? 'block' : 'none';
        }

        async function menuAction(action) {
            if (!selectedNode) return;
            const { id, name, type } = selectedNode;

            if (action === 'copy') {
                clipboard = { id, name, type, mode: 'copy' };
                setStatus(`Copied: ${name}`);
            }
            if (action === 'paste') {
                if (!clipboard) return;

                setStatus(`Pasting ${clipboard.name} into ${name}...`);

                try {
                    const res = await fetch(`${API}/action/copy`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            project_id: currentProjectId,
                            source_id: clipboard.id,
                            target_parent_id: id,
                            is_folder: clipboard.type === 'folder'
                        })
                    });

                    if (res.ok) {
                        setStatus("Paste Successful!");
                        // Trigger Refresh of children
                        selectedNode.row.dataset.loaded = 'false';
                        toggleExpand(selectedNode.row, null, id, type); // Collapse/Expand to refresh
                    } else {
                        const err = await res.json();
                        setStatus(`Error: ${err.detail || 'Unknown error'}`);
                    }
                } catch (e) {
                    console.error(e);
                    setStatus("Paste Error.");
                }
            }
            if (action === 'new-folder') {
                const newName = prompt("New Folder Name:");
                if (newName) await createFolder(id, newName);
            }
            if (action === 'delete') {
                if (confirm(`Delete ${name}? (Simulation)`)) {
                    setStatus("Delete endpoint pending.");
                }
            }
        }

        async function createFolder(parentId, name) {
            setStatus(`Creating folder ${name}...`);
            try {
                const res = await fetch(`${API}/folders`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        project_id: currentProjectId,
                        parent_id: parentId,
                        name: name
                    })
                });

                if (res.ok) {
                    const json = await res.json();
                    setStatus("Folder Created!");

                    // Add to UI if parent is expanded
                    const row = document.querySelector(`.tree-item[data-id="${parentId}"]`);
                    if (row && row.dataset.loaded === 'true') {
                        row.childrenDiv.appendChild(createNodeEl(json.data.id, name, 'folder', parentId));
                        row.childrenDiv.classList.remove('hidden');
                    }

                    return json.data.id;
                } else {
                    setStatus("Folder creation failed.");
                    return null;
                }
            } catch (e) {
                console.warn(e);
                return null;
            }
        }

        // --- Recursive Upload Logic ---

        const dropZone = document.getElementById('dropZone');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', (e) => dropZone.classList.remove('dragover'));

        dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');

            const items = e.dataTransfer.items;
            if (items) {
                const entries = [];
                for (let i = 0; i < items.length; i++) {
                    const entry = items[i].webkitGetAsEntry();
                    if (entry) entries.push(entry);
                }
                await handleEntries(entries);
            } else {
                // Fallback for very old browsers
                handleStructureUpload(e.dataTransfer.files);
            }
        });

        document.getElementById('fileInput').addEventListener('change', (e) => {
            handleStructureUpload(e.target.files);
        });

        async function handleEntries(entries) {
            if (!selectedNode || selectedNode.type !== 'folder') {
                alert("Select a target folder first.");
                return;
            }

            setStatus("Scanning folder structure...");
            const filesToUpload = []; // {file, relPath}

            for (const entry of entries) {
                // If dropping a root folder "ProjectA", we want contents to be inside "ProjectA/"
                // But performRecursiveUpload expects relPath.
                // If relPath is "", it goes to rootTarget.
                // If relPath is "FolderA/", it creates FolderA in rootTarget.
                if (entry.isDirectory) {
                    await traverseEntry(entry, entry.name + "/", filesToUpload);
                } else {
                    await traverseEntry(entry, "", filesToUpload);
                }
            }

            if (filesToUpload.length === 0) return;

            // Verbose Confirmation
            const folderCount = new Set(filesToUpload.map(x => x.relPath).filter(x => x)).size;
            if (!confirm(`Structure Scan Complete:\nFiles: ${filesToUpload.length}\nFolders to Create: ${folderCount}\n\nProceed?`)) return;

            performRecursiveUpload(filesToUpload, selectedNode.id);
        }

        async function traverseEntry(entry, path, list) {
            if (entry.isFile) {
                const file = await new Promise(resolve => entry.file(resolve));
                // Add relPath property to the file object wrapper for our logic
                // Ensure path ends with / if it exists
                let finalPath = path;
                if (finalPath.endsWith('/')) finalPath = finalPath.slice(0, -1);

                // If path is "FolderA", the file relPath should be "FolderA" (meaning it belongs to FolderA)
                // Wait, performRecursiveUpload logic: 
                // item.relPath is the FOLDER path.
                // So if file is "FolderA/doc.txt", relPath should be "FolderA".
                // If path passed here includes the folder name "FolderA/", then yes.

                // Correction: path passed in recursion usually includes trailing slash
                // If I pass "FolderA/" to subdirectory, and this is a file inside it,
                // finalPath should be "FolderA".

                // Removing trailing slash usually safe for folderMap lookup
                if (finalPath.endsWith('/')) finalPath = finalPath.slice(0, -1);

                list.push({ file: file, relPath: finalPath });
            } else if (entry.isDirectory) {
                const dirReader = entry.createReader();
                const entries = await new Promise(resolve => {
                    dirReader.readEntries(resolve);
                });
                for (const child of entries) {
                    await traverseEntry(child, path + child.name + "/", list);
                }
            }
        }

        async function handleStructureUpload(fileList) {
            if (!selectedNode || selectedNode.type !== 'folder') {
                alert("Select a target folder first.");
                return;
            }

            const files = Array.from(fileList);
            const uploadList = [];

            // Debug Log
            console.log("Processing input files:", files.length);

            files.forEach(f => {
                let relPath = "";
                if (f.webkitRelativePath) {
                    const rawPath = f.webkitRelativePath;
                    const normalized = rawPath.replace(/\\/g, '/');
                    const parts = normalized.split('/');
                    parts.pop(); // Remove filename

                    if (parts.length > 0) {
                        relPath = parts.join('/') + '/';
                    }
                }

                if (relPath.endsWith('/')) relPath = relPath.slice(0, -1);

                uploadList.push({ file: f, relPath: relPath });
            });

            // Verbose Confirmation
            const folderSet = new Set(uploadList.map(x => x.relPath).filter(x => x !== ""));
            const folderCount = folderSet.size;
            const distinctFolders = Array.from(folderSet).slice(0, 5).join(", ");
            const more = folderSet.size > 5 ? `... (+${folderSet.size - 5} more)` : "";

            // Log for User
            logStatus(`Analysis Input: ${files.length} files.`);
            logStatus(`Detected Folders: ${folderCount} (${distinctFolders} ${more})`);

            if (files.length === 0) return;

            let msg = `Ready to upload ${files.length} files.`;
            if (folderCount > 0) {
                msg += `\nWill create ${folderCount} folders:\n${distinctFolders} ${more}`;
            } else {
                msg += `\nNote: All files will be placed directly in "${selectedNode.name}" (No subfolders detected).`;
            }

            if (!confirm(msg)) return;
            performRecursiveUpload(uploadList, selectedNode.id);
        }
        const uploadList = files.map(f => {
            const rawPath = f.webkitRelativePath || f.name;
            const normalized = rawPath.replace(/\\/g, '/');
            const parts = normalized.split('/');
            parts.pop();
            const relPath = parts.join('/') + (parts.length > 0 ? '/' : '');

            // Remove trailing slash for consistency
            const cleanRel = relPath.endsWith('/') ? relPath.slice(0, -1) : relPath;

            return { file: f, relPath: cleanRel };
        });

        if (!confirm(`Upload ${files.length} files?`)) return;
        performRecursiveUpload(uploadList, selectedNode.id);
        }

        async function performRecursiveUpload(list, rootTargetId) {
            const folderMap = { "": rootTargetId };
            const uniquePaths = [...new Set(list.map(x => x.relPath).filter(p => p !== ""))].sort();

            const statusDiv = document.getElementById('uploadStatus');
            statusDiv.classList.remove('hidden');
            const uiProgress = document.getElementById('progressBar');
            const percentText = document.getElementById('uploadPercent');

            // Clear Log
            const logDiv = document.getElementById('uploadLog');
            if (logDiv) logDiv.innerHTML = '';

            logStatus("Starting upload process...", 'info');

            // Create Folders
            for (let i = 0; i < uniquePaths.length; i++) {
                const fullPath = uniquePaths[i];
                if (folderMap[fullPath]) continue;

                const parts = fullPath.split('/').filter(x => x);
                const name = parts.pop();
                const parentPath = parts.join('/') + (parts.length > 0 ? '/' : '');

                const parentId = folderMap[parentPath];

                if (parentId) {
                    logStatus(`Creating folder: ${fullPath}...`);
                    const newId = await createFolder(parentId, name);
                    if (!newId) {
                        logStatus(`Failed to create folder: ${name}. Stopping.`, 'error');
                        alert(`Failed to create folder: ${name}. Stopping upload.`);
                        return;
                    }
                    folderMap[fullPath] = newId;
                }

                const pct = Math.round((i / (uniquePaths.length + list.length)) * 100);
                uiProgress.style.width = `${pct}%`;
            }

            // Upload Files
            for (let i = 0; i < list.length; i++) {
                const item = list[i];
                const targetId = folderMap[item.relPath] || rootTargetId;

                logStatus(`Uploading ${item.file.name}...`);
                try {
                    await apiUploadFile(targetId, item.file);
                    logStatus(`Uploaded ${item.file.name}`, 'success');
                } catch (e) {
                    logStatus(`Error uploading ${item.file.name}: ${e}`, 'error');
                }

                const pct = Math.round(((uniquePaths.length + i + 1) / (uniquePaths.length + list.length)) * 100);
                uiProgress.style.width = `${pct}%`;
                percentText.innerText = `${pct}%`;
            }

            logStatus("Upload Sequence Complete!", 'success');
            // Removed auto-hide
            // setTimeout(() => statusDiv.classList.add('hidden'), 3000);

            // Refresh User Interface
            if (selectedNode && selectedNode.row) {
                selectedNode.row.dataset.loaded = 'false';
                toggleExpand(selectedNode.row, null, selectedNode.id, selectedNode.type);
            }
        }

        async function apiUploadFile(folderId, file) {
            const formData = new FormData();
            formData.append('project_id', currentProjectId);
            formData.append('folder_id', folderId);
            formData.append('file', file);

            await fetch(`${API}/upload`, { method: 'POST', body: formData });
        }

        function addDnD(row, id, type) {
            row.draggable = true;
            row.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', JSON.stringify({ id, type }));
                e.dataTransfer.effectAllowed = 'move';
            });
            row.addEventListener('dragover', (e) => {
                e.preventDefault();
                if (type === 'folder') row.classList.add('drag-over');
            });
            row.addEventListener('dragleave', () => row.classList.remove('drag-over'));
            row.addEventListener('drop', async (e) => {
                e.preventDefault();
                row.classList.remove('drag-over');
                if (type !== 'folder') return;

                const data = e.dataTransfer.getData('text/plain');
                if (!data) return;

                const src = JSON.parse(data);
                if (src.id === id) return;

                if (confirm(`Move item to ${row.innerText.trim()}?`)) {
                    setStatus("Move API not connected.");
                }
            });
            row.addEventListener('contextmenu', (e) => showContextMenu(e, { row, id, type, name: row.innerText.trim(), parentId: null }));
        }

    </script>
</body>

</html>