<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sheet Manager | AO Labs</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- SortableJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>

    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            overflow: hidden;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .panel-header {
            background: #252526;
            border-bottom: 1px solid #3e3e42;
            height: 40px;
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-weight: 500;
            font-size: 13px;
        }

        /* Left Panel Items */
        .sheet-item {
            display: flex;
            align-items: center;
            height: 32px;
            /* Fixed Height matching Grid Rows */
            padding: 0 8px;
            cursor: grab;
            border-bottom: 1px solid #2d2d2d;
            background: #252526;
            font-size: 12px;
            user-select: none;
        }

        .sheet-item:hover {
            background: #2a2d2e;
        }

        .sheet-item.selected {
            background: #37373d;
            border-left: 2px solid #007acc;
        }

        .sheet-item.ui-sortable-helper {
            opacity: 0.8;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        .drag-handle {
            color: #555;
            margin-right: 8px;
            cursor: Grab;
        }

        /* Grid Right Panel */
        .data-grid {
            display: grid;
            overflow: auto;
            position: relative;
        }

        .grid-header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #2d2d2d;
            display: flex;
        }

        .grid-col-header {
            border-right: 1px solid #3e3e42;
            border-bottom: 1px solid #3e3e42;
            padding: 0 8px;
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 11px;
            color: #ccc;
            white-space: nowrap;
            overflow: hidden;
            height: 40px;
            /* Header Height */
        }

        .grid-row {
            display: flex;
            height: 32px;
        }

        /* Must Match Sheet Item Height */
        .grid-cell {
            border-right: 1px solid #333;
            border-bottom: 1px solid #333;
            background: #1e1e1e;
            color: #d4d4d4;
            display: flex;
            align-items: center;
            padding: 0 4px;
        }

        .grid-cell input {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
            color: inherit;
            font-size: 12px;
            outline: none;
        }

        .grid-cell input:focus {
            background: #003366;
        }

        /* Slot Numbers */
        .slot-indices {
            width: 30px;
            flex-shrink: 0;
            background: #252526;
            border-right: 1px solid #3e3e42;
        }

        .slot-index {
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            border-bottom: 1px solid #2d2d2d;
        }

        /* Excel Features */
        .fill-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 6px;
            height: 6px;
            background: #007acc;
            cursor: crosshair;
            z-index: 5;
            display: none;
        }

        .grid-cell:hover .fill-handle,
        .grid-cell.focused .fill-handle {
            display: block;
        }

        .grid-cell.selected-range {
            background: rgba(0, 122, 204, 0.2) !important;
            border: 1px solid #007acc;
        }

        .grid-cell.selected-cell {
            background: rgba(0, 122, 204, 0.4) !important;
            border: 2px solid #007acc;
        }

        /* Resizing */
        .resizer {
            display: inline-block;
            width: 5px;
            height: 100%;
            position: absolute;
            right: 0;
            top: 0;
            cursor: col-resize;
            z-index: 10;
        }

        .resizer:hover {
            background: #007acc;
        }
    </style>
    <!-- SheetJS -->
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
</head>

<body class="flex flex-col h-screen">

    <!-- Navbar -->
    <header class="h-12 bg-[#007acc] text-white flex items-center justify-between px-4 shadow-md z-20">
        <div class="flex items-center gap-2">
            <i class="fas fa-layer-group"></i>
            <span class="font-bold tracking-wide">AO Sheet Manager</span>
            <span class="text-xs bg-white/20 px-2 rounded ml-2" id="project-name">Loading...</span>
        </div>

        <!-- Browser Org Selector -->
        <div class="flex items-center gap-2 ml-4">
            <label class="text-xs text-slate-300">Browser Org:</label>
            <select id="browser-org-select" onchange="changeBrowserOrg(this.value)"
                class="bg-[#3e3e42] text-xs text-white border border-[#555] rounded px-2 py-1 outline-none focus:border-[#007acc]">
                <option value="default">Default</option>
            </select>
        </div>

        <div class="flex gap-2">
            <input type="file" id="excel-upload" hidden accept=".xlsx, .xls" onchange="handleExcelUpload(this)">
            <button onclick="document.getElementById('excel-upload').click()"
                class="bg-green-700 hover:bg-green-600 px-3 py-1.5 rounded text-sm font-bold shadow transition-colors"
                title="Importar Excel">
                <i class="fas fa-file-excel"></i> Importar Excel
            </button>
            <button onclick="addManualSheet()"
                class="bg-[#3e3e42] hover:bg-[#4e4e52] px-3 py-1.5 rounded text-sm font-bold shadow transition-colors"
                title="Agregar Fila Manual">
                <i class="fas fa-plus-square"></i>
            </button>
            <div class="w-px bg-white/20 mx-1"></div>

            <button onclick="openParamsModal()"
                class="bg-red-600 hover:bg-red-500 px-3 py-1.5 rounded text-sm font-bold shadow transition-colors"
                title="Seleccionar Parámetros">
                <i class="fas fa-columns"></i> Parámetros
            </button>
            <button onclick="openTemplateModal()"
                class="bg-gray-700 hover:bg-gray-600 px-3 py-1.5 rounded text-sm font-bold shadow transition-colors"
                title="Cargar Template">
                <i class="fas fa-list"></i> Templates
            </button>
            <button onclick="saveTemplate()"
                class="bg-gray-700 hover:bg-gray-600 px-3 py-1.5 rounded text-sm font-bold shadow transition-colors"
                title="Guardar Vista Actual como Template">
                <i class="fas fa-save"></i>
            </button>
            <div class="w-px bg-white/20 mx-1"></div>
            <button onclick="applyChanges()"
                class="bg-green-600 hover:bg-green-500 px-4 py-1.5 rounded text-sm font-bold shadow transition-colors flex items-center gap-2">
                <i class="fas fa-check"></i> Aplicar Cambios
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex-1 flex overflow-hidden">

        <!-- LEFT: Structure Panel -->
        <aside class="w-80 flex flex-col border-r border-[#3e3e42] bg-[#1e1e1e] flex-shrink-0 z-10 shadow-xl">
            <div class="panel-header justify-between">
                <span>Estructura (Project Browser)</span>
                <div class="flex gap-1">
                    <button class="text-gray-400 hover:text-white" onclick="addGroup()" title="Add Group Separator"><i
                            class="fas fa-folder-plus"></i></button>
                    <!-- <button class="text-gray-400 hover:text-white" onclick="deleteSelected()" title="Remove Selected"><i
                            class="fas fa-trash"></i></button> -->
                </div>
            </div>

            <!-- Search Bar -->
            <div class="p-2 border-b border-[#3e3e42]">
                <input type="text" id="sheet-search" placeholder="Filtrar Sheets..."
                    class="w-full bg-[#2d2d2d] text-xs text-white p-1 rounded border border-[#3e3e42] outline-none focus:border-[#007acc]"
                    oninput="filterSheets(this.value)">
            </div>

            <div class="flex-1 overflow-y-auto custom-scrollbar p-2" id="structure-container">
                <!-- ROOT LIST -->
                <ul id="tree-root" class="nested-sortable space-y-[2px]">
                    <!-- Items Injected Here -->
                </ul>
            </div>
        </aside>

        <!-- RIGHT: Data Grid -->
        <main class="flex-1 flex flex-col bg-[#1e1e1e] overflow-hidden relative">
            <div class="panel-header">
                <span>Editor de Parámetros (Orden Definido por Estructura)</span>
                <span class="ml-4 text-xs text-gray-500 italic">Mover un item a la izquierda mueve toda su fila de
                    datos.</span>
            </div>

            <div class="flex flex-1 overflow-hidden relative" id="grid-container">
                <!-- Row Indices -->
                <div class="slot-indices flex flex-col" id="slot-indices-col">
                    <!-- 1, 2, 3... -->
                </div>

                <div class="flex-1 overflow-auto custom-scrollbar" onscroll="syncScroll(this)">
                    <div id="data-grid-content" style="min-width: 1000px;">
                        <!-- Headers + Input Rows -->
                    </div>
                </div>
            </div>
        </main>

    </div>

    <!-- JS Logic -->
    <script>
        let SESSION_ID = new URLSearchParams(window.location.search).get('session_id');
        let API_BASE = "/api/plugin/sheets";

        // APP STATE
        let PARAM_DEFS = [];
        let VISIBLE_COLS = null;

        // Tree Data: Recursive Structure
        // Node: { id: string, type: 'sheet'|'group', name: string, number: string, params: {}, children: [], collapsed: false }
        let TREE_DATA = [];

        document.addEventListener('DOMContentLoaded', init);

        async function init() {
            if (!SESSION_ID) return alert("No session ID");

            // Fetch Data
            try {
                const res = await fetch(`${API_BASE}/session/${SESSION_ID}`);
                if (!res.ok) throw new Error("Error fetching session");

                const json = await res.json();
                if (json.status !== "ok") {
                    throw new Error(json.message || "Session not found");
                }

                const data = json.data;
                document.getElementById('project-name').innerText = data.project;

                // Init Params
                PARAM_DEFS = data.param_definitions || [];
                PARAM_DEFS = PARAM_DEFS.filter(p => p !== "Sheet Number" && p !== "Sheet Name");
                VISIBLE_COLS = [...PARAM_DEFS];

                // V2 Data Unpacking
                let sheets = [];
                if (data.sheets && !Array.isArray(data.sheets) && data.sheets.version === 'v2') {
                    // V2 Structure
                    sheets = data.sheets.sheets || [];
                    initBrowserSchemes(data.sheets.browser_schemes || []);
                } else {
                    // Legacy
                    sheets = data.sheets || [];
                }

                // Initial Build (Default Scheme)
                TREE_DATA = buildStructure(sheets);

                renderTree();
                renderGrid();

            } catch (err) {
                console.error(err);
                document.body.innerHTML += `
                <div class="fixed inset-0 bg-black/90 flex flex-col items-center justify-center z-50 text-center p-8">
                    <i class="fas fa-exclamation-triangle text-6xl text-red-500 mb-4"></i>
                    <h1 class="text-3xl font-bold text-white mb-2">Sesión Error</h1>
                    <p class="text-gray-400 max-w-md mb-6">${err.message}</p>
                    <button onclick="window.close()" class="bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded font-bold">Cerrar</button>
                </div>
                `;
            }
        }

        // Global Builder (for init and re-org)
        window.buildStructure = function (items) {
            const rootNodes = [];

            // Normalize Items (ensure they have params/children props)
            const normalized = items.map(s => {
                // If s is already a node (has type='sheet'), preserve it. 
                // If s is raw data (from backend), map it.
                // FORCE TYPE: If missing or generic, ensure it's marked as sheet
                let type = s.type;
                if (!type) type = 'sheet';

                if (type === 'sheet' && s.params && s.children) return { ...s, type: 'sheet' };

                return {
                    id: s.id || generateId(),
                    type: 'sheet',
                    number: s.number,
                    name: s.name,
                    params: s.params_data || {},
                    folder_path: s.folder_path || [], // Legacy Support
                    browser_paths: s.browser_paths || {}, // New V2
                    children: []
                };
            });

            normalized.forEach(node => {
                // Determine Path
                let path = [];
                if (node.browser_paths && node.browser_paths[currentScheme]) {
                    path = node.browser_paths[currentScheme];
                } else if (node.folder_path) {
                    path = node.folder_path;
                }

                let currentLevel = rootNodes;

                path.forEach(folderName => {
                    let group = currentLevel.find(n => n.type === 'group' && n.name === folderName);
                    if (!group) {
                        group = {
                            id: generateId(),
                            type: 'group',
                            name: folderName,
                            children: [],
                            targetParam: null
                        };
                        currentLevel.push(group);
                    }
                    currentLevel = group.children;
                });

                currentLevel.push(node);
            });

            sortTree(rootNodes);
            return rootNodes;
        };

        function sortTree(nodes) {
            nodes.sort((a, b) => {
                if (a.type === b.type) {
                    if (a.type === 'sheet') {
                        return a.number.localeCompare(b.number, undefined, { numeric: true });
                    }
                    return a.name.localeCompare(b.name, undefined, { numeric: true });
                }
                return a.type === 'group' ? -1 : 1;
            });

            nodes.forEach(n => {
                if (n.children && n.children.length > 0) sortTree(n.children);
            });
        }


        function generateId() {
            return 'id-' + Math.random().toString(36).substr(2, 9);
        }

        // --- RENDER TREE (Left Panel) ---

        function renderTree() {
            const root = document.getElementById('tree-root');
            root.innerHTML = '';

            TREE_DATA.forEach(node => {
                root.appendChild(createNodeElement(node));
            });

            initSortables();
        }

        function createNodeElement(node) {
            const li = document.createElement('li');
            li.dataset.id = node.id;
            li.dataset.type = node.type;
            li.className = "relative";

            if (node.type === 'group') {
                li.innerHTML = `
                    <div class="sheet-item group-header bg-[#2d2d2d] border border-[#3e3e42] mb-[2px] rounded flex items-center pr-2">
                        <i class="fas fa-grip-vertical drag-handle text-gray-600 cursor-grab px-2 py-1"></i>
                        <i class="fas fa-folder text-yellow-500 mr-2 text-sm"></i>
                        <span class="font-bold text-xs text-gray-300 flex-1 py-1 outline-none" contenteditable="true" onblur="updateNodeName('${node.id}', this.innerText)">${node.name}</span>
                        ${node.targetParam ? `<span class="text-[10px] bg-[#007acc] px-1 rounded mr-2" title="Target Param">${node.targetParam}</span>` : ''}
                        <i class="fas fa-cog text-[10px] text-gray-400 hover:text-white cursor-pointer p-1 mr-1" onclick="openGroupConfig('${node.id}')" title="Configurar Parámetro"></i>
                        <i class="fas fa-trash text-[10px] text-gray-600 hover:text-red-500 cursor-pointer p-1" onclick="deleteNode('${node.id}')"></i>
                    </div>
                    <ul class="nested-sortable ml-4 border-l border-[#3e3e42] pl-1 space-y-[2px] min-h-[10px] pb-1">
                        <!-- Children -->
                    </ul>
                `;

                const ul = li.querySelector('ul');
                if (node.children) {
                    node.children.forEach(child => {
                        ul.appendChild(createNodeElement(child));
                    });
                }

            } else {
                // SHEET
                li.innerHTML = `
                    <div class="sheet-item bg-[#252526] hover:bg-[#2a2d2e] border-b border-[#2d2d2d] flex items-center h-[32px] pr-2" onclick="highlightRow('${node.id}')">
                        <i class="fas fa-grip-vertical drag-handle text-gray-600 cursor-grab px-2"></i>
                        <i class="fas fa-file-alt text-blue-400 mr-2 text-xs"></i>
                        <span class="font-mono text-xs text-green-400 mr-2 w-16 truncate" title="${node.number}">${node.number}</span>
                        <span class="text-xs text-gray-300 truncate flex-1" title="${node.name}">${node.name}</span>
                    </div>
                `;
            }

            return li;
        }

        function initSortables() {
            const nestedSortables = document.querySelectorAll('.nested-sortable');

            nestedSortables.forEach(el => {
                new Sortable(el, {
                    group: 'nested', // Shared group for drag between lists
                    handle: '.drag-handle',
                    animation: 150,
                    fallbackOnBody: true,
                    swapThreshold: 0.65,
                    onEnd: function (evt) {
                        // REBUILD TREE DATA FROM DOM
                        rebuildTreeFromDOM();
                        renderGrid(); // Sync Logic: Grid order adapts to Tree order
                    }
                });
            });
        }

        function rebuildTreeFromDOM() {
            const rootUl = document.getElementById('tree-root');
            TREE_DATA = parseUl(rootUl);
        }

        function parseUl(ul) {
            const nodes = [];
            Array.from(ul.children).forEach(li => {
                const id = li.dataset.id;
                // Find original node data (preserve params!)
                const original = findNodeRecursive(id, TREE_DATA);

                if (original) {
                    const newNode = { ...original };

                    if (original.type === 'group') {
                        const childUl = li.querySelector('ul');
                        newNode.children = childUl ? parseUl(childUl) : [];
                    }
                    else {
                        newNode.children = [];
                    }

                    nodes.push(newNode);
                }
            });
            return nodes;
        }

        function findNodeRecursive(id, nodes) {
            for (let n of nodes) {
                if (n.id === id) return n;
                if (n.children && n.children.length > 0) {
                    const found = findNodeRecursive(id, n.children);
                    if (found) return found;
                }
            }
            return null;
        }

        // --- RENDER GRID (Right Panel) ---

        // Column Widths State
        let COL_WIDTHS = {}; // { 'Sheet Number': 150, ... }

        function renderGrid() {
            const flatList = flattenTree(TREE_DATA);

            const container = document.getElementById('data-grid-content');
            const indices = document.getElementById('slot-indices-col');

            // Filter Cols
            const activeParams = VISIBLE_COLS || PARAM_DEFS;
            const COLS = ["Sheet Number", "Sheet Name", ...activeParams];

            // Headers
            let html = `<div class="grid-row" style="background: #2d2d2d;">`;
            COLS.forEach((c, idx) => {
                const width = COL_WIDTHS[c] || 150;
                html += `<div class="grid-col-header relative" style="width: ${width}px; flex-shrink:0;" data-col="${c}">
                            ${c}
                            <div class="resizer" onmousedown="initResize(event, '${c}')"></div>
                         </div>`;
            });
            html += `</div>`;

            // Rows
            let idxHtml = `<div class="slot-index" style="height: 40px; background: #2d2d2d;">#</div>`;

            flatList.forEach((node, idx) => {
                const rowId = node.id;
                idxHtml += `<div class="slot-index" onclick="selectRow('${rowId}')">${idx + 1}</div>`;

                html += `<div class="grid-row" data-row-id="${rowId}">`;

                // Number
                html += createCell(rowId, 'number', node.number, 'Sheet Number');
                // Name
                html += createCell(rowId, 'name', node.name, 'Sheet Name');

                // Params
                PARAM_DEFS.forEach(p => {
                    if (activeParams.includes(p)) {
                        // Guard against undefined params
                        const params = node.params || {};
                        const val = params[p] || "";
                        html += createCell(rowId, 'param:' + p, val, p);
                    }
                });

                html += `</div>`;
            });

            container.innerHTML = html;
            indices.innerHTML = idxHtml;
        }

        function createCell(id, key, value, colName) {
            const width = COL_WIDTHS[colName] || 150;
            return `
            <div class="grid-cell relative" style="width: ${width}px; flex-shrink:0;" data-col="${key}"
                 onmousedown="startSelect(event, '${id}', '${key}')"
                 onmouseover="updateSelect(event, '${id}', '${key}'); handleDragOver(event, '${id}', '${key}')">
                <input type="text" value="${value}" 
                   oninput="updateNodeData('${id}', '${key}', this.value)" 
                   onfocus="this.parentElement.classList.add('focused')"
                   onblur="handleCellBlur('${id}', '${key}', this)"
                   class="w-full h-full bg-transparent outline-none text-xs px-1 text-gray-300">
                <div class="fill-handle" onmousedown="startDrag(event, '${id}', '${key}')"></div>
            </div>`;
        }

        function flattenTree(nodes) {
            let flat = [];
            nodes.forEach(n => {
                // Relaxed check: Include anything that isn't a group
                if (n.type !== 'group') {
                    flat.push(n);
                }
                if (n.children) {
                    flat = flat.concat(flattenTree(n.children));
                }
            });
            return flat;
        }

        // --- DATA UPDATES ---

        function updateNodeData(id, key, val) {
            const node = findNodeRecursive(id, TREE_DATA);
            if (!node) return;

            if (key === 'number') node.number = val;
            else if (key === 'name') node.name = val;
            else if (key.startsWith('param:')) {
                const p = key.split(':')[1];
                node.params[p] = val;
            }

            // If Number or Name changed, update Left Panel visual immediately
            if (key === 'number' || key === 'name') updateTreeVisual(node);
        }

        function updateTreeVisual(node) {
            const li = document.querySelector(`li[data-id="${node.id}"]`);
            if (!li) return;

            if (node.type === 'sheet') {
                const num = li.querySelector('.font-mono');
                const name = li.querySelector('span:last-child');
                if (num) { num.innerText = node.number; num.title = node.number; }
                if (name) { name.innerText = node.name; name.title = node.name; }
            }
        }

        function updateNodeName(id, val) {
            const node = findNodeRecursive(id, TREE_DATA);
            if (node) node.name = val;
        }

        // --- ACTIONS ---

        function addGroup() {
            const name = prompt("Nombre del Grupo:", "Nuevo Grupo");
            if (!name) return;

            const newGroup = {
                id: generateId(),
                type: 'group',
                name: name,
                children: []
            };

            TREE_DATA.push(newGroup);
            renderTree();
            renderGrid();
        }

        function deleteNode(id) {
            if (!confirm("Eliminar grupo y su contenido?")) return;

            function removeFrom(nodes) {
                const idx = nodes.findIndex(n => n.id === id);
                if (idx > -1) {
                    nodes.splice(idx, 1);
                    return true;
                }
                for (let n of nodes) {
                    if (n.children && removeFrom(n.children)) return true;
                }
                return false;
            }

            removeFrom(TREE_DATA);
            renderTree();
            renderGrid();
        }


        function highlightRow(id) {
            // Remove previous highlight
            document.querySelectorAll('.grid-row').forEach(r => r.style.backgroundColor = '');

            const row = document.querySelector(`.grid-row[data-row-id="${id}"]`);
            if (row) {
                row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                row.style.backgroundColor = '#37373d';

                // Highlight
                row.animate([
                    { backgroundColor: '#007acc' },
                    { backgroundColor: '#37373d' }
                ], { duration: 500 });
            }
        }

        function syncScroll(el) {
            const indices = document.getElementById('slot-indices-col');
            if (indices) indices.scrollTop = el.scrollTop;
        }

        async function applyChanges() {
            // Flatten Tree AND Inject Group Parameters
            const updates = [];

            function traverse(nodes, currentParams) {
                nodes.forEach(node => {
                    if (node.type === 'group') {
                        // If group has a target param, we take its value
                        // Inherit currentParams
                        const nextParams = { ...currentParams };

                        if (node.targetParam) {
                            nextParams[node.targetParam] = node.name;
                        } else {
                            // Fallback: Auto-assign to AO-SheetManagerGroupX? 
                            // User asked for explicit menu. If not set, maybe we just don't send it? 
                            // Or we map by depth? Let's use depth as fallback if no targetParam
                            // But complexity increases. Let's stick to: If targetParam set, use it.
                        }

                        traverse(node.children, nextParams);

                    } else {
                        // It's a sheet. 
                        const sheet = {
                            id: node.id,
                            number: node.number,
                            name: node.name,
                            params: { ...node.params, ...currentParams } // Merge Inherited Group Params
                        };

                        updates.push(sheet);
                    }
                });
            }

            traverse(TREE_DATA, {});

            if (!confirm(`Se actualizarán ${updates.length} Sheets en Revit. ¿Continuar?`)) return;

            try {
                const res = await fetch(`${API_BASE}/apply`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: SESSION_ID, updates: updates })
                });

                const json = await res.json();
                if (json.status === "ok") {
                    alert("Cambios enviados a Revit.");
                    window.close();
                } else {
                    alert("Error: " + json.message);
                }
            } catch (e) {
                alert("Error de conexión");
            }
        }

        function filterSheets(query) {
            query = query.toLowerCase();
            const lis = document.querySelectorAll('li[data-type="sheet"]');

            lis.forEach(li => {
                const text = li.innerText.toLowerCase();
                // Very simple visibility toggle
                if (text.includes(query)) {
                    li.style.display = 'block';
                } else {
                    li.style.display = 'none';
                }
            });
        }

        // --- TEMPLATES LOGIC ---

        async function loadTemplates() {
            const res = await fetch(`${API_BASE}/templates`);
            const json = await res.json();
            if (json.status === "ok") return json.templates;
            return [];
        }

        async function saveTemplate() {
            const name = prompt("Nombre del Template (e.g., 'Nombramiento Synergy'):");
            if (!name) return;

            const config = {
                visible_columns: PARAM_DEFS // For now saving all
            };

            const res = await fetch(`${API_BASE}/templates`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, config })
            });
            const json = await res.json();
            if (json.status === "ok") alert("Template Guardado");
            else alert("Error: " + json.message);
        }

        async function openTemplateModal() {
            const tpls = await loadTemplates();

            let html = `
    <div id="tpl-modal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
        <div class="bg-[#252526] p-6 rounded shadow-xl w-96 border border-[#3e3e42]">
            <h2 class="text-xl font-bold mb-4">Cargar Template</h2>
            <ul class="space-y-2 max-h-60 overflow-y-auto mb-4 custom-scrollbar">
                ${tpls.map(t => `
                <li class="p-2 hover:bg-[#37373d] cursor-pointer flex justify-between group"
                    onclick="applyTemplate(${t.id})">
                    <span>${t.name}</span>
                    <i class="fas fa-play text-xs opacity-0 group-hover:opacity-100 text-green-400 mt-1"></i>
                </li>
                `).join('')}
                ${tpls.length === 0 ? '<li class="text-gray-500 italic">No hay templates guardados.</li>' : ''}
            </ul>
            <div class="flex justify-between">
                <button onclick="document.getElementById('tpl-modal').remove()"
                    class="text-gray-400 hover:text-white">Cerrar</button>
            </div>
        </div>
    </div>`;
            document.body.insertAdjacentHTML('beforeend', html);
        }

        async function applyTemplate(id) {
            const tpls = await loadTemplates();
            const tpl = tpls.find(t => t.id === id);
            if (tpl) {
                // Apply Columns
                if (tpl.config.visible_columns) {
                    // Filter out core columns to avoid duplication/errors
                    const core = ["Sheet Number", "Sheet Name"];
                    const saved = tpl.config.visible_columns.filter(p => !core.includes(p));

                    // Validate against current PARAM_DEFS to avoid showing deleted params
                    VISIBLE_COLS = saved.filter(p => PARAM_DEFS.includes(p));

                    renderGrid();
                }
                document.getElementById('tpl-modal').remove();
            }
        }

        // --- PARAMS FILTER MODAL ---

        function openParamsModal() {
            // Checkboxes for each PARAM_DEF
            // visual state based on VISIBLE_COLS

            const checks = PARAM_DEFS.map(p => {
                const checked = VISIBLE_COLS.includes(p) ? 'checked' : '';
                return `
                <label class="flex items-center space-x-2 p-2 hover:bg-[#37373d] rounded cursor-pointer">
                    <input type="checkbox" ${checked} onchange="toggleParam('${p}')" class="form-checkbox text-[#007acc] rounded bg-[#2d2d2d] border-[#3e3e42]">
                    <span class="text-sm">${p}</span>
                </label>
                `;
            }).join('');

            const html = `
    <div id="params-modal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
        <div class="bg-[#252526] p-6 rounded shadow-xl w-[500px] border border-[#3e3e42] flex flex-col max-h-[80vh]">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Seleccionar Parámetros Visibles</h2>
                <div class="flex gap-2">
                     <button onclick="toggleAllParams(true)" class="text-xs bg-[#3e3e42] hover:bg-[#4e4e52] px-2 py-1 rounded">Todas</button>
                     <button onclick="toggleAllParams(false)" class="text-xs bg-[#3e3e42] hover:bg-[#4e4e52] px-2 py-1 rounded">Ninguna</button>
                </div>
            </div>
            
            <div class="flex-1 overflow-y-auto custom-scrollbar grid grid-cols-2 gap-2 content-start">
                ${checks}
            </div>
            
            <div class="flex justify-end mt-4 pt-4 border-t border-[#3e3e42]">
                <button onclick="document.getElementById('params-modal').remove()"
                    class="bg-[#007acc] hover:bg-[#005a9e] text-white px-4 py-1.5 rounded font-bold shadow transition-colors">Listo</button>
            </div>
        </div>
    </div>`;
            document.body.insertAdjacentHTML('beforeend', html);
        }

        function toggleParam(p) {
            if (VISIBLE_COLS.includes(p)) {
                VISIBLE_COLS = VISIBLE_COLS.filter(x => x !== p);
            } else {
                // Maintain Order based on PARAM_DEFS
                VISIBLE_COLS.push(p);
                // Sort by original index
                VISIBLE_COLS.sort((a, b) => PARAM_DEFS.indexOf(a) - PARAM_DEFS.indexOf(b));
            }
            renderGrid();
        }

        function toggleAllParams(enable) {
            if (enable) {
                VISIBLE_COLS = [...PARAM_DEFS];
            } else {
                VISIBLE_COLS = [];
            }
            // Re-render modal content? or just close/reopen? 
            // Better: update checkboxes DOM
            document.getElementById('params-modal').remove();
            openParamsModal(); // Simple re-render of modal

            renderGrid();
        }

        // --- EXCEL FEATURES ---
        let dragStart = null;
        let dragCurrent = null;
        let isDragging = false;

        document.addEventListener('mouseup', endDrag);

        function startDrag(e, id, key) {
            e.stopPropagation();
            e.preventDefault();
            const node = findNodeRecursive(id, TREE_DATA);
            if (!node) return;

            // Resolve Value
            let val = "";
            if (key === 'number') val = node.number;
            else if (key === 'name') val = node.name;
            else if (key.startsWith('param:')) val = node.params[key.split(':')[1]];

            isDragging = true;
            dragStart = { id, key, val };
        }

        function handleDragOver(e, id, key) {
            if (!isDragging) return;
            if (key !== dragStart.key) return; // Vertical only

            dragCurrent = { id, key };

            // Visual Highlight
            document.querySelectorAll('.grid-cell').forEach(c => c.classList.remove('selected-range'));

            const flat = flattenTree(TREE_DATA);
            const startIdx = flat.findIndex(n => n.id === dragStart.id);
            const endIdx = flat.findIndex(n => n.id === dragCurrent.id);
            if (startIdx === -1 || endIdx === -1) return;

            const min = Math.min(startIdx, endIdx);
            const max = Math.max(startIdx, endIdx);

            for (let i = min; i <= max; i++) {
                const rowId = flat[i].id;
                const cell = document.querySelector(`.grid-row[data-row-id="${rowId}"] .grid-cell[data-col="${key}"]`);
                if (cell) cell.classList.add('selected-range');
            }
        }

        function endDrag(e) {
            if (!isDragging) return;
            isDragging = false;
            document.querySelectorAll('.grid-cell').forEach(c => c.classList.remove('selected-range'));

            if (dragStart && dragCurrent && dragStart.key === dragCurrent.key) {
                // Check for Ctrl Key aka "Copy Mode"
                const isCopyMode = e.ctrlKey || e.metaKey;
                applyFill(dragStart, dragCurrent, isCopyMode);
            }
            dragStart = null;
            dragCurrent = null;
        }

        function applyFill(start, end, forceCopy = false) {
            const flat = flattenTree(TREE_DATA);
            const startIdx = flat.findIndex(n => n.id === start.id);
            const endIdx = flat.findIndex(n => n.id === end.id);

            if (startIdx === -1 || endIdx === -1) return;

            const min = Math.min(startIdx, endIdx);
            const max = Math.max(startIdx, endIdx);

            let val = start.val;

            // Series Logic
            let num = null;
            let prefix = val;
            let digits = 0;

            if (!forceCopy) {
                const match = typeof val === 'string' ? val.match(/^(.*?)(\d+)$/) : null;
                if (match) {
                    prefix = match[1];
                    num = parseInt(match[2], 10);
                    digits = match[2].length;
                }
            }

            for (let i = min; i <= max; i++) {
                if (flat[i].id === start.id) continue;

                let newVal = val;
                if (num !== null) {
                    const dist = i - startIdx;
                    const currentNum = num + dist;
                    newVal = prefix + String(currentNum).padStart(digits, '0');
                }

                updateNodeData(flat[i].id, start.key, newVal);
            }
            renderGrid();
        }

        function handleCellBlur(id, key, input) {
            const val = input.value;
            if (val.startsWith('=')) {
                const node = findNodeRecursive(id, TREE_DATA);
                if (!node) return;

                let formula = val.substring(1);

                const getVal = (colName) => {
                    if (colName === "Sheet Number") return node.number;
                    if (colName === "Sheet Name") return node.name;
                    return node.params[colName] || "";
                };

                let result = formula.replace(/\[(.*?)\]/g, (match, p1) => {
                    return getVal(p1);
                });

                updateNodeData(id, key, result);
                input.value = result;
            }
            input.parentElement.classList.remove('focused');
        }

        // --- CLIPBOARD PASTE SUPPORT ---

        document.addEventListener('paste', handlePaste);

        function handlePaste(e) {
            // Only handle if we have a focused cell input
            const active = document.activeElement;
            if (!active || !active.tagName === 'INPUT' || !active.closest('.grid-cell')) return;

            e.preventDefault();
            const clipboardData = (e.clipboardData || window.clipboardData).getData('text');
            if (!clipboardData) return;

            const startCell = active.closest('.grid-cell');
            const startRowId = startCell.parentElement.dataset.rowId;
            const startKey = startCell.dataset.col;

            parseAndPaste(clipboardData, startRowId, startKey);
        }

        function parseAndPaste(text, startRowId, startKey) {
            const rows = text.split(/\r\n|\n|\r/).filter(r => r.length > 0);
            if (rows.length === 0) return;

            const flat = flattenTree(TREE_DATA);
            const startIdx = flat.findIndex(n => n.id === startRowId);
            if (startIdx === -1) return;

            // Determine Coilumn Order map
            const activeParams = VISIBLE_COLS || PARAM_DEFS;
            const COLS = ["Sheet Number", "Sheet Name", ...activeParams];
            // Mapping Key -> Index
            const colKeys = ["number", "name", ...activeParams.map(p => 'param:' + p)];

            const startColIdx = colKeys.indexOf(startKey);
            if (startColIdx === -1) return;

            let updated = 0;

            rows.forEach((rowStr, rOffset) => {
                const targetRowIdx = startIdx + rOffset;
                if (targetRowIdx >= flat.length) return; // Stop if OOB

                const targetNode = flat[targetRowIdx];
                const cells = rowStr.split('\t');

                cells.forEach((val, cOffset) => {
                    const targetColIdx = startColIdx + cOffset;
                    if (targetColIdx >= colKeys.length) return; // Stop if OOB

                    const targetKey = colKeys[targetColIdx];
                    updateNodeData(targetNode.id, targetKey, val.trim());
                    updated++;
                });
            });

            if (updated > 0) {
                renderGrid();
                // alert(`Pegados ${updated} valores.`);
            }
        }

        // --- PHASE 3 LOGIC (Groups, Import, Add) ---

        // 1. Group Config
        function openGroupConfig(groupId) {
            const node = findNodeRecursive(groupId, TREE_DATA);
            if (!node) return;

            const options = PARAM_DEFS.map(p => `<option value="${p}" ${node.targetParam === p ? 'selected' : ''}>${p}</option>`).join('');

            const html = `
            <div id="group-modal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                <div class="bg-[#252526] p-6 rounded shadow-xl w-96 border border-[#3e3e42]">
                    <h2 class="text-xl font-bold mb-4">Configurar Grupo: ${node.name}</h2>
                    <label class="block text-sm text-gray-400 mb-2">Asignar Parámetro Revit:</label>
                    <select id="group-param-select" class="w-full bg-[#1e1e1e] text-white p-2 rounded border border-[#3e3e42]">
                        <option value="">-- Ninguno (Auto A/B/C) --</option>
                        ${options}
                    </select>
                    <div class="flex justify-end mt-4 pt-4 border-t border-[#3e3e42] gap-2">
                        <button onclick="document.getElementById('group-modal').remove()" class="text-gray-400 hover:text-white px-3">Cancelar</button>
                        <button onclick="saveGroupParam('${groupId}')" class="bg-[#007acc] hover:bg-[#005a9e] text-white px-4 py-1.5 rounded font-bold">Guardar</button>
                    </div>
                </div>
            </div>`;
            document.body.insertAdjacentHTML('beforeend', html);
        }

        function saveGroupParam(groupId) {
            const val = document.getElementById('group-param-select').value;
            const node = findNodeRecursive(groupId, TREE_DATA);
            if (node) {
                node.targetParam = val || null;
            }
            document.getElementById('group-modal').remove();
            renderTree();
        }

        // 2. Manual Sheet
        function addManualSheet() {
            const newSheet = {
                id: generateId(),
                type: 'sheet',
                number: "A-000",
                name: "New Sheet",
                params: {},
                children: []
            };
            TREE_DATA.push(newSheet);
            renderTree();
            renderGrid();
        }

        // 3. Excel Import with Conflict Resolution
        async function handleExcelUpload(input) {
            const file = input.files[0];
            if (!file) return;

            const buffer = await file.arrayBuffer();
            const workbook = XLSX.read(buffer);

            // Show Sheet Selection
            const selectedSheetNames = await selectExcelSheets(workbook.SheetNames);
            if (!selectedSheetNames || selectedSheetNames.length === 0) {
                input.value = "";
                return;
            }

            const flat = flattenTree(TREE_DATA);
            const existingNumbers = new Set(flat.filter(n => n.type === 'sheet').map(n => n.number));

            let newSheetsBuffer = [];
            let conflictSheetsBuffer = []; // { rawData, existingNode }

            selectedSheetNames.forEach(sheetName => {
                const sheet = workbook.Sheets[sheetName];
                const rows = XLSX.utils.sheet_to_json(sheet);

                rows.forEach(row => {
                    // Validation
                    const values = Object.values(row).filter(v => v !== null && v !== "" && v !== undefined);
                    if (values.length === 0) return;

                    const numKey = Object.keys(row).find(k => k.toLowerCase().includes("number") || k.toLowerCase().includes("numero"));
                    const nameKey = Object.keys(row).find(k => k.toLowerCase().includes("name") || k.toLowerCase().includes("nombre"));

                    if (!numKey) return;
                    const sNum = String(row[numKey]).trim();
                    if (!sNum) return;
                    const sName = nameKey ? String(row[nameKey]).trim() : "Unnamed";

                    // Parse Params
                    const params = {};
                    Object.keys(row).forEach(k => {
                        if (k !== numKey && k !== nameKey && PARAM_DEFS.includes(k)) {
                            params[k] = String(row[k]);
                        }
                    });

                    const sheetObj = {
                        number: sNum,
                        name: sName,
                        params: params
                    };

                    if (existingNumbers.has(sNum)) {
                        conflictSheetsBuffer.push(sheetObj);
                    } else {
                        newSheetsBuffer.push(sheetObj);
                    }
                });
            });

            // Process Non-Conflicting Immediately
            if (newSheetsBuffer.length > 0) {
                newSheetsBuffer.forEach(s => {
                    TREE_DATA.push({
                        id: generateId(),
                        type: 'sheet',
                        number: s.number,
                        name: s.name,
                        params: s.params,
                        children: []
                    });
                });
            }

            // Handle Conflicts
            if (conflictSheetsBuffer.length > 0) {
                showConflictModal(conflictSheetsBuffer, () => {
                    input.value = ""; // Cleanup
                    renderTree();
                    renderGrid();
                });
            } else {
                input.value = "";
                renderTree();
                renderGrid();
                alert(`${newSheetsBuffer.length} sheets importados.`);
            }
        }

        function showConflictModal(conflicts, onComplete) {
            const html = `
            <div id="conflict-modal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                <div class="bg-[#252526] p-6 rounded shadow-xl w-[600px] border border-[#3e3e42] flex flex-col max-h-[80vh]">
                    <div class="flex items-center gap-3 mb-4 text-yellow-500">
                        <i class="fas fa-exclamation-triangle text-2xl"></i>
                        <h2 class="text-xl font-bold text-white">Conflictos Encontrados: ${conflicts.length}</h2>
                    </div>
                    <p class="text-sm text-gray-400 mb-4">Algunos números de sheet ya existen en el sistema. ¿Qué acción deseas realizar?</p>
                    
                    <div class="flex gap-2 mb-4 border-b border-[#3e3e42] pb-4">
                        <button onclick="resolveConflicts('ignore')" class="flex-1 bg-[#3e3e42] hover:bg-[#4e4e52] text-white py-2 rounded text-sm font-bold">
                            🛑 Ignorar (Conservar Actual)
                        </button>
                        <button onclick="resolveConflicts('overwrite')" class="flex-1 bg-red-800 hover:bg-red-700 text-white py-2 rounded text-sm font-bold">
                            🔄 Sobrescribir Todo
                        </button>
                    </div>

                    <div class="flex justify-between items-center mb-2">
                         <span class="text-xs font-bold text-gray-300">Selección Manual (Marcar para Sobrescribir)</span>
                         <div>
                            <button onclick="toggleAllConflicts(true)" class="text-[10px] bg-[#3e3e42] px-2 py-1 rounded hover:text-white">Marcar Todos</button>
                            <button onclick="toggleAllConflicts(false)" class="text-[10px] bg-[#3e3e42] px-2 py-1 rounded hover:text-white">Desmarcar</button>
                         </div>
                    </div>

                    <div class="flex-1 overflow-y-auto custom-scrollbar border border-[#3e3e42] rounded bg-[#1e1e1e] p-2 mb-4">
                        <ul id="conflict-list" class="space-y-1">
                            ${conflicts.map((c, i) => `
                            <li class="flex items-center gap-3 p-2 hover:bg-[#2d2d2d] rounded">
                                <input type="checkbox" id="conflict-chk-${i}" class="conflict-check form-checkbox text-[#007acc] rounded bg-[#2d2d2d] border-[#555]" checked>
                                <div class="flex-1 min-w-0">
                                    <div class="flex justify-between">
                                        <span class="font-mono text-green-400 text-xs font-bold">${c.number}</span>
                                        <span class="text-[10px] text-gray-500">Conflict</span>
                                    </div>
                                    <div class="text-xs text-gray-300 truncate">${c.name}</div>
                                </div>
                            </li>
                            `).join('')}
                        </ul>
                    </div>

                    <div class="flex justify-end">
                        <button onclick="resolveConflicts('manual')" class="bg-[#007acc] hover:bg-[#005a9e] text-white px-6 py-2 rounded font-bold shadow">
                            Aplicar Selección
                        </button>
                    </div>
                </div>
            </div>`;

            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            document.body.appendChild(wrapper.firstElementChild);

            // Bind Resolve Logic
            window.resolveConflicts = (mode) => {
                const flat = flattenTree(TREE_DATA);

                if (mode === 'ignore') {
                    // Do nothing for conflicts
                    alert("Se ignoraron los conflictos.");
                } else if (mode === 'overwrite') {
                    // Apply ALL
                    conflicts.forEach(c => applyConflictUpdate(c, flat));
                    alert(`${conflicts.length} sheets actualizados.`);
                } else if (mode === 'manual') {
                    // Check checkboxes
                    let count = 0;
                    conflicts.forEach((c, i) => {
                        const chk = document.getElementById(`conflict-chk-${i}`);
                        if (chk && chk.checked) {
                            applyConflictUpdate(c, flat);
                            count++;
                        }
                    });
                    alert(`${count} sheets actualizados.`);
                }

                document.getElementById('conflict-modal').remove();
                delete window.resolveConflicts;
                if (onComplete) onComplete();
            };

            window.toggleAllConflicts = (state) => {
                document.querySelectorAll('.conflict-check').forEach(chk => chk.checked = state);
            }
        }

        function applyConflictUpdate(excelData, flatNodes) {
            const node = flatNodes.find(n => n.type === 'sheet' && n.number === excelData.number);
            if (node) {
                node.name = excelData.name;
                // Merge params
                Object.keys(excelData.params).forEach(k => {
                    node.params[k] = excelData.params[k];
                });
            }
        }

        function selectExcelSheets(sheetNames) {
            return new Promise((resolve) => {
                const checks = sheetNames.map((s, i) => `
                    <label class="flex items-center space-x-2 p-2 hover:bg-[#37373d] rounded cursor-pointer">
                        <input type="checkbox" value="${s}" ${i === 0 ? 'checked' : ''} class="form-checkbox text-[#007acc] rounded bg-[#2d2d2d] border-[#3e3e42]">
                        <span class="text-sm">${s}</span>
                    </label>
                `).join('');

                const html = `
                <div id="excel-modal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50">
                    <div class="bg-[#252526] p-6 rounded shadow-xl w-[400px] border border-[#3e3e42] flex flex-col max-h-[80vh]">
                        <h2 class="text-xl font-bold mb-4">Seleccionar Hojas de Excel</h2>
                        <div class="text-xs text-gray-400 mb-2">Se encontraron ${sheetNames.length} hojas.</div>
                        <div class="flex-1 overflow-y-auto custom-scrollbar flex flex-col gap-1 mb-4">
                            ${checks}
                        </div>
                        <div class="flex justify-end gap-2 pt-4 border-t border-[#3e3e42]">
                            <button id="cancel-excel" class="text-gray-400 hover:text-white px-3">Cancelar</button>
                            <button id="confirm-excel" class="bg-[#007acc] hover:bg-[#005a9e] text-white px-4 py-1.5 rounded font-bold">Importar</button>
                        </div>
                    </div>
                </div>`;

                const wrapper = document.createElement('div');
                wrapper.innerHTML = html;
                document.body.appendChild(wrapper.firstElementChild);

                document.getElementById('cancel-excel').onclick = () => {
                    document.getElementById('excel-modal').remove();
                    resolve(null);
                };

                document.getElementById('confirm-excel').onclick = () => {
                    const inputs = document.querySelectorAll('#excel-modal input:checked');
                    const selected = Array.from(inputs).map(i => i.value);
                    document.getElementById('excel-modal').remove();
                    resolve(selected);
                };
            });
        }

        // --- PHASE 4 LOGIC (Selection & Resizing) ---

        // Selection State
        let isSelecting = false;
        let selectStartNode = null; // { id, key }

        document.addEventListener('mouseup', () => {
            isSelecting = false;
            // End Resize
            if (resizingCol) {
                resizingCol = null;
            }
        });

        // Multi-select Deletion
        document.addEventListener('keydown', (e) => {
            if ((e.key === 'Delete' || e.key === 'Backspace') && !e.target.matches('input:focus')) {
                deleteSelectedCells();
            }
        });

        function startSelect(e, id, key) {
            if (e.target.classList.contains('fill-handle')) return; // Ignore if clicking handle
            // If right click?
            if (e.button !== 0) return;

            isSelecting = true;
            selectStartNode = { id, key };

            // Clear previous
            document.querySelectorAll('.grid-cell').forEach(c => c.classList.remove('selected-cell'));

            // Select start cell
            highlightRange(selectStartNode, selectStartNode);
        }

        function updateSelect(e, id, key) {
            if (!isSelecting) return;
            if (!selectStartNode) return;

            // Highlight Range from Start to Current
            highlightRange(selectStartNode, { id, key });
        }

        function highlightRange(start, end) {
            const flat = flattenTree(TREE_DATA);
            const startIdx = flat.findIndex(n => n.id === start.id);
            const endIdx = flat.findIndex(n => n.id === end.id);

            if (startIdx === -1 || endIdx === -1) return;

            const minRow = Math.min(startIdx, endIdx);
            const maxRow = Math.max(startIdx, endIdx);

            // Cols? We only have Key. 
            // If we want rect selection across columns, we need column indices.
            // Let's assume activeParams defines order.
            const cols = ["number", "name", ...VISIBLE_COLS.map(p => 'param:' + p)];
            const startColIdx = cols.indexOf(start.key);
            const endColIdx = cols.indexOf(end.key);

            if (startColIdx === -1 || endColIdx === -1) return;

            const minCol = Math.min(startColIdx, endColIdx);
            const maxCol = Math.max(startColIdx, endColIdx);

            const selectedCols = cols.slice(minCol, maxCol + 1);

            // Clear all first? OR just add? 
            document.querySelectorAll('.grid-cell').forEach(c => c.classList.remove('selected-cell')); // brute force clear

            for (let i = minRow; i <= maxRow; i++) {
                const rowNodes = flat[i];
                selectedCols.forEach(cKey => {
                    // Find cell
                    // We need a better selector. we have key in data-col? 
                    // key for number is 'number', name is 'name', param is 'param:Name'
                    // data-col matches key? In createCell: data-col="${key}"
                    // Yes.
                    const cell = document.querySelector(`.grid-row[data-row-id="${rowNodes.id}"] .grid-cell[data-col="${cKey}"]`);
                    if (cell) cell.classList.add('selected-cell');
                });
            }
        }

        function deleteSelectedCells() {
            const cells = document.querySelectorAll('.grid-cell.selected-cell');
            if (cells.length === 0) return;

            if (!confirm(`Borrar contenido de ${cells.length} celdas?`)) return;

            cells.forEach(cell => {
                const row = cell.closest('.grid-row');
                const rowId = row.dataset.rowId;
                const key = cell.dataset.col;

                // Update Data
                updateNodeData(rowId, key, "");
            });
            renderGrid();
        }

        // Resizing Logic
        let resizingCol = null;
        let startX = 0;
        let startWidth = 0;
        let resizingKey = ""; // to save to COL_WIDTHS

        function initResize(e, colKey) {
            e.preventDefault();
            e.stopPropagation();
            resizingCol = e.target.parentElement;
            resizingKey = colKey;
            startX = e.pageX;
            startWidth = resizingCol.offsetWidth;
        }

        document.addEventListener('mousemove', (e) => {
            if (resizingCol) {
                const diff = e.pageX - startX;
                const newW = Math.max(50, startWidth + diff);
                resizingCol.style.width = newW + 'px';

                // Directly update cells in this column for performance
                // Selector: data-col="param:Name" ?
                // Wait, renderGrid passes 'c' (Column Name) to initResize.
                // createCell uses 'param:'+p as key.
                // We need to match.
                // Headers: "Sheet Number", "Sheet Name", "ParamX"
                // Keys: "number", "name", "param:ParamX"

                let dataCol = "";
                if (resizingKey === "Sheet Number") dataCol = "number";
                else if (resizingKey === "Sheet Name") dataCol = "name";
                else dataCol = "param:" + resizingKey;

                const cells = document.querySelectorAll(`.grid-cell[data-col="${dataCol}"]`);
                cells.forEach(c => c.style.width = newW + 'px');

                COL_WIDTHS[resizingKey] = newW; // Save state
            }
        });

        // --- BROWSER ORG & APPLY CHANGES ---

        let currentScheme = "default";

        function initBrowserSchemes(schemes) {
            const sel = document.getElementById('browser-org-select');
            if (!schemes || schemes.length === 0) {
                sel.style.display = 'none';
                return;
            }
            sel.innerHTML = '';
            schemes.forEach(s => {
                const opt = document.createElement('option');
                opt.value = s;
                opt.innerText = s;
                sel.appendChild(opt);
            });
            // Default to first or 'AO' if exists
            if (schemes.includes('AO')) sel.value = 'AO';
            currentScheme = sel.value;
        }

        function changeBrowserOrg(scheme) {
            currentScheme = scheme;
            // Re-process Data
            // We need to rebuild the Tree structure based on new paths
            // 1. Flatten current state (preserve edits)
            const flat = flattenTree(TREE_DATA); // This gets current rows with edits

            // 2. Re-Group
            // We need access to original 'browser_paths' which might be lost if we only used 'folder_path'
            // Fix: Ensure 'browser_paths' is stored in node data

            TREE_DATA = buildStructure(flat); // Will use currentScheme global
            render();
        }

        // Modified buildStructure to use Scheme
        // Existing buildStructure needs to be updated or replaced? 
        // I will overwrite it if I can find it, but sticking it here might duplicate if not careful.
        // Assuming strict replacement if I matched the function previously.
        // Since I didn't match it, I can't overwrite easily. 
        // Strategy: Override the function by redefining it here (JS allows this if executed after).
        // But better to find it. I'll search for it later.

        // Let's implement applyChanges logic
        async function applyChanges() {
            const btn = document.querySelector('button[onclick="applyChanges()"]');
            const originalText = btn.innerHTML;
            btn.innerText = "Enviando...";
            btn.disabled = true;

            const flat = flattenTree(TREE_DATA);
            const updates = flat.map(node => {
                // If it's a group, skip? OR create folder? Plugin only handles Sheets.
                if (node.type === 'group') return null;

                // Check for 'browser_paths' - we don't send this back usually
                // Params
                const params = [];
                // node.data contains the sheet data. 
                // We need to map active columns back to list or dict

                // Construct Params Dict
                // We stored edits in node.data
                const paramsDict = {};
                Object.keys(node.data).forEach(k => {
                    if (k === 'number' || k === 'name' || k === 'id') return;
                    // Only send if it matches a known parameter definition?
                    // Backend handles it.
                    paramsDict[k] = node.data[k];
                });

                return {
                    id: node.id,
                    number: node.data.number || "",
                    name: node.data.name || "",
                    params: paramsDict,
                    is_new: node.id.startsWith('new-') || node.isNew // Flag for plugin
                };
            }).filter(x => x !== null);

            try {
                // Get Session ID from URL
                const urlParams = new URLSearchParams(window.location.search);
                const sessionId = urlParams.get('session_id');

                const res = await fetch('/api/plugin/sheets/apply', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        updates: updates
                    })
                });

                const json = await res.json();
                if (json.status === 'ok') {
                    alert("Cambios enviados a Revit. El plugin procesará la actualización.");
                    // Optional: remove 'new' flags? loadData()?
                } else {
                    alert("Error: " + json.message);
                }
            } catch (e) {
                alert("Error de conexión: " + e.message);
            }

            btn.innerHTML = originalText;
            btn.disabled = false;
        }

        // --- Override buildStructure for Browser Org Support ---
        // We need to hook into the existing logic. 
        // Since I can't see the original buildStructure, I will redefine it safely.

        const originalBuildStructure = window.buildStructure || null;

        window.buildStructure = function (flatItems) {
            // Group by path
            const root = [];
            const groups = {}; // path -> groupNode

            flatItems.forEach(item => {
                // Determine Path based on Current Scheme
                let path = [];
                // item.browser_paths is the new property. 
                // If not present (legacy item), use item.folder_path
                if (item.browser_paths && item.browser_paths[currentScheme]) {
                    path = item.browser_paths[currentScheme];
                } else if (item.folder_path) {
                    path = item.folder_path; // Fallback
                }

                // Normal Grouping Logic (re-implemented simplistically)
                let currentLevel = root;
                let currentPath = "";

                // Traverse path
                for (let i = 0; i < path.length; i++) {
                    const part = path[i];
                    const fullPath = currentPath ? currentPath + "/" + part : part;

                    let group = groups[fullPath];
                    if (!group) {
                        group = {
                            id: "group-" + fullPath,
                            type: 'group',
                            name: part,
                            children: [],
                            expanded: true, // Default open?
                            level: i
                        };
                        groups[fullPath] = group;
                        currentLevel.push(group);
                    }
                    currentLevel = group.children;
                    currentPath = fullPath;
                }

                currentLevel.push(item);
            });

            return root;
        };

        // Hook into initialization to populate schemes
        const originalLoad = window.onload;
        window.onload = async function () {
            if (originalLoad) await originalLoad();

            // Verify if we have schemes in INITIAL_DATA equivalent (server response)
            // We need to sniff where data comes from.
            // If fetch('/session/...') is called, we hook that.
            // Let's assume we can access the data after load.
        };

        // We need to patch the fetch data handler
        // Since I can't find it easily, I will expose a global function 'onDataLoaded' call
        // expecting the user might refresh.
        // Actually, the HTML template might render JSON into a variable.
        // Let's wait for actual data load.

    </script>
</body>

</html>